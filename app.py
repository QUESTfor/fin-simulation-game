# -*- coding: utf-8 -*-
"""è¼¸å‡ºç”¨.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19VGse-uwjKnR4C2bk11juKX8p3w1UGSZ
"""

# Commented out IPython magic to ensure Python compatibility.
# # @title
# %%writefile app.py
# import streamlit as st
# import plotly.graph_objects as go
# import random
# from datetime import datetime
# import json
# import firebase_admin
# from firebase_admin import credentials, firestore
# import time
# import numpy as np
# import pandas as pd
# 
# # ============= MONTHLY EVENTS SYSTEM =============
# 
# MONTHLY_EVENTS = {
#     1: {
#         "name": "å…¬å‘Šï¼šéŠæˆ²é–‹å§‹ï¼å¸‚å ´ç©©å®š<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸à¸¡ â€“ à¸•à¸¥à¸²à¸”à¸¡à¸µà¹€à¸ªà¸–à¸µà¸¢à¸£à¸ à¸²à¸ï¼‰",
#         "description": "æ­¡è¿ä¾†åˆ°é‡‘èæ¨¡æ“¬éŠæˆ²ï¼ç›®å‰å¸‚å ´ç‹€æ³ç©©å®š ï¼ˆà¸¢à¸´à¸™à¸”à¸µà¸•à¹‰à¸­à¸™à¸£à¸±à¸šà¸ªà¸¹à¹ˆà¹€à¸à¸¡à¸ˆà¸³à¸¥à¸­à¸‡à¸—à¸²à¸‡à¸à¸²à¸£à¹€à¸‡à¸´à¸™! à¸ªà¸ à¸²à¸§à¸°à¸•à¸¥à¸²à¸”à¸‚à¸“à¸°à¸™à¸µà¹‰à¸¡à¸µà¸„à¸§à¸²à¸¡à¸¡à¸±à¹ˆà¸™à¸„à¸‡ï¼‰.",
#         "alert": {},
#         "effects": {}
#     },
#     2: {
#         "name": "å…¬å‘Šï¼šç”Ÿé†«æ–°å‰µå…¬å¸æŠ€è¡“çªç ´ï¼Œè‚¡ç¥¨å¤§æ¼²<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¸ªà¸•à¸²à¸£à¹Œà¸—à¸­à¸±à¸à¸”à¹‰à¸²à¸™à¸Šà¸µà¸§à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¹€à¸à¸´à¸”à¸„à¸§à¸²à¸¡à¸à¹‰à¸²à¸§à¸«à¸™à¹‰à¸²à¸—à¸²à¸‡à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ à¸£à¸²à¸„à¸²à¸«à¸¸à¹‰à¸™à¸à¸¸à¹ˆà¸‡à¸‚à¸¶à¹‰à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¸¡à¸²à¸ï¼‰",
#         "description": "*",
#         "alert": "ğŸ§¬ Biomedical stocks soar +30%!",
#         "effects": {
#             "biomedical_multiplier": 1.30
#         }
#     },
#     3: {
#         "name": "å…¬å‘Šï¼šå¸‚å ´éç†±ï¼åˆ©ç‡é£†å‡<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¸•à¸¥à¸²à¸”à¸£à¹‰à¸­à¸™à¹à¸£à¸‡à¹€à¸à¸´à¸™à¹„à¸› â€“ à¸­à¸±à¸•à¸£à¸²à¸”à¸­à¸à¹€à¸šà¸µà¹‰à¸¢à¸à¸¸à¹ˆà¸‡à¸ªà¸¹à¸‡à¸‚à¸¶à¹‰à¸™ï¼‰",
#         "description": "å¤®è¡Œç‚ºäº†é™æº«ç¶“æ¿Ÿï¼Œå°‡åˆ©ç‡å¾ 1.5% èª¿å‡è‡³ 3% ï¼ˆà¸˜à¸™à¸²à¸„à¸²à¸£à¸à¸¥à¸²à¸‡à¸›à¸£à¸±à¸šà¸‚à¸¶à¹‰à¸™à¸­à¸±à¸•à¸£à¸²à¸”à¸­à¸à¹€à¸šà¸µà¹‰à¸¢à¸ˆà¸²à¸ 1.5% à¹€à¸›à¹‡à¸™ 3% à¹€à¸à¸·à¹ˆà¸­à¸Šà¸°à¸¥à¸­à¹€à¸¨à¸£à¸©à¸à¸à¸´à¸ˆï¼‰",
#         "alert": "ğŸ”¥ åˆ©ç‡é£†å‡è‡³ 3%ï¼å¹¾ä¹æ‰€æœ‰è‚¡ç¥¨ä¸‹è·Œ 7%ï¼ ï¼ˆà¸­à¸±à¸•à¸£à¸²à¸”à¸­à¸à¹€à¸šà¸µà¹‰à¸¢à¸à¸¸à¹ˆà¸‡à¸‚à¸¶à¹‰à¸™à¹€à¸›à¹‡à¸™ 3%! à¸«à¸¸à¹‰à¸™à¹€à¸à¸·à¸­à¸šà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¸›à¸£à¸±à¸šà¸•à¸±à¸§à¸¥à¸‡ 7%!ï¼‰",
#         "effects": {
#             "interest_rate_change": +1.5,  # From 1.5% to 3%
#             "loan_rate_change": +1.5,
#             "stocks_multiplier": 0.93,  # All stocks -7%
#             "biomedical_multiplier": 0.93,
#             "real_estate_multiplier": 0.93,
#             "etf_multiplier": 0.93,
#             "mutual_multiplier": 0.93
#         }
#     },
#     4: {
#         "name": "å…¬å‘Šï¼šçƒå…‹è˜­ï¼ä¿„ç¾…æ–¯æˆ°çˆ­å‡ç´š<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¸ªà¸‡à¸„à¸£à¸²à¸¡à¸¢à¸¹à¹€à¸„à¸£à¸™â€“à¸£à¸±à¸ªà¹€à¸‹à¸µà¸¢à¸—à¸§à¸µà¸„à¸§à¸²à¸¡à¸£à¸¸à¸™à¹à¸£à¸‡à¸‚à¸¶à¹‰à¸™ï¼‰",
#         "description": "æˆ°çˆ­æ¨å‹•é«˜é€šè†¨èˆ‡é«˜åˆ©ç‡ï¼Œä¸å‹•ç”¢æˆç‚ºé¿é¢¨æ¸¯ ï¼ˆà¸ªà¸‡à¸„à¸£à¸²à¸¡à¸—à¸³à¹ƒà¸«à¹‰à¹€à¸à¸´à¸”à¹€à¸‡à¸´à¸™à¹€à¸Ÿà¹‰à¸­à¸ªà¸¹à¸‡à¹à¸¥à¸°à¸­à¸±à¸•à¸£à¸²à¸”à¸­à¸à¹€à¸šà¸µà¹‰à¸¢à¸ªà¸¹à¸‡ à¸­à¸ªà¸±à¸‡à¸«à¸²à¸£à¸´à¸¡à¸—à¸£à¸±à¸à¸¢à¹Œà¸à¸¥à¸²à¸¢à¹€à¸›à¹‡à¸™à¸ªà¸´à¸™à¸—à¸£à¸±à¸à¸¢à¹Œà¸›à¸¥à¸­à¸”à¸ à¸±à¸¢ï¼‰",
#         "alert": "âš”ï¸ æˆ°çˆ­æ¨å‡é€šè†¨ï¼Pruksa ä¸å‹•ç”¢ä½œç‚ºé¿é¢¨æ¸¯ä¸Šæ¼² 15%ï¼ ï¼ˆà¸ªà¸‡à¸„à¸£à¸²à¸¡à¸œà¸¥à¸±à¸à¸”à¸±à¸™à¹€à¸‡à¸´à¸™à¹€à¸Ÿà¹‰à¸­! à¸à¸¤à¸à¸©à¸² à¹€à¸£à¸µà¸¢à¸¥à¹€à¸­à¸ªà¹€à¸•à¸—à¸›à¸£à¸±à¸šà¸•à¸±à¸§à¸‚à¸¶à¹‰à¸™ 15% à¹ƒà¸™à¸à¸²à¸™à¸°à¸ªà¸´à¸™à¸—à¸£à¸±à¸à¸¢à¹Œà¸›à¸¥à¸­à¸”à¸ à¸±à¸¢!ï¼‰",
#         "effects": {
#             "inflation_change": +2.0,
#             "real_estate_multiplier": 1.15,  # Pruksa +15%
#             "expense_multiplier": 1.02,
#             "food_multiplier": 1.02
#         }
#     },
#     5: {
#         "name": "å…¬å‘Šï¼šç”Ÿé†«æ–°å‰µå…¬å¸æ•¸æ“šé€ å‡æ›å…‰<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¹€à¸›à¸´à¸”à¹‚à¸›à¸‡à¸à¸²à¸£à¸›à¸¥à¸­à¸¡à¹à¸›à¸¥à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸‚à¸­à¸‡à¸ªà¸•à¸²à¸£à¹Œà¸—à¸­à¸±à¸à¸”à¹‰à¸²à¸™à¸Šà¸µà¸§à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œï¼‰",
#         "description": "*",
#         "alert": "ğŸš¨ ç”Ÿé†«è©æ¬ºæ›å…‰ï¼è‚¡åƒ¹æš´è·Œï¼ ï¼ˆà¸à¸²à¸£à¸‰à¹‰à¸­à¹‚à¸à¸‡à¸”à¹‰à¸²à¸™à¸Šà¸µà¸§à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸–à¸¹à¸à¹€à¸›à¸´à¸”à¹‚à¸›à¸‡! à¸£à¸²à¸„à¸²à¸«à¸¸à¹‰à¸™à¸£à¹ˆà¸§à¸‡à¸¥à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¸«à¸™à¸±à¸!ï¼‰ï¼‰",
#         "effects": {
#             "biomedical_multiplier": 0.10  # -90% crash!
#         }
#     },
#     6: {
#         "name": "å…¬å‘Šï¼šåœ‹æœƒè§£æ•£ï¼æå‰é¸èˆ‰ï¼›ä¸¦å°‡æ–¼ä¸‹å€‹æœˆçµç®—ï¼Œè«‹è¨˜å¾—å°‡æ‰€æœ‰è‚¡ç¥¨èˆ‡åŸºé‡‘è³£å‡º<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¸¢à¸¸à¸šà¸ªà¸ à¸² â€“ à¹€à¸¥à¸·à¸­à¸à¸•à¸±à¹‰à¸‡à¸à¹ˆà¸­à¸™à¸à¸³à¸«à¸™à¸” à¹à¸¥à¸°à¸ˆà¸°à¸¡à¸µà¸à¸²à¸£à¸Šà¸³à¸£à¸°à¸šà¸±à¸à¸Šà¸µà¹ƒà¸™à¹€à¸”à¸·à¸­à¸™à¸–à¸±à¸”à¹„à¸› à¹‚à¸›à¸£à¸”à¸­à¸¢à¹ˆà¸²à¸¥à¸·à¸¡à¸‚à¸²à¸¢à¸«à¸¸à¹‰à¸™à¹à¸¥à¸°à¸à¸­à¸‡à¸—à¸¸à¸™à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”ï¼‰",
#         "description": "ç¸½ç†Anutin Charnvirakulè§£æ•£åœ‹æœƒï¼Œç‚ºæå‰é¸èˆ‰é‹ªè·¯ ï¼ˆà¸™à¸²à¸¢à¸à¸£à¸±à¸à¸¡à¸™à¸•à¸£à¸µ à¸­à¸™à¸¸à¸—à¸´à¸™ à¸Šà¸²à¸à¸§à¸µà¸£à¸à¸¹à¸¥ à¸¢à¸¸à¸šà¸ªà¸ à¸² à¸›à¸¹à¸—à¸²à¸‡à¸ªà¸¹à¹ˆà¸à¸²à¸£à¹€à¸¥à¸·à¸­à¸à¸•à¸±à¹‰à¸‡à¸à¹ˆà¸­à¸™à¸à¸³à¸«à¸™à¸”ï¼‰",
#         "alert": "ğŸ—³ï¸ æ”¿æ²»ä¸ç¢ºå®šæ€§å‡é«˜ï¼ç”Ÿé†«èˆ‡ä¸å‹•ç”¢è‚¡ä¸‹è·Œ 10%ï¼ ï¼ˆà¸„à¸§à¸²à¸¡à¹„à¸¡à¹ˆà¹à¸™à¹ˆà¸™à¸­à¸™à¸—à¸²à¸‡à¸à¸²à¸£à¹€à¸¡à¸·à¸­à¸‡à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™! à¸«à¸¸à¹‰à¸™à¸à¸¥à¸¸à¹ˆà¸¡à¸Šà¸µà¸§à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¹à¸¥à¸°à¸­à¸ªà¸±à¸‡à¸«à¸²à¸£à¸´à¸¡à¸—à¸£à¸±à¸à¸¢à¹Œà¸›à¸£à¸±à¸šà¸•à¸±à¸§à¸¥à¸‡ 10%!ï¼‰",
#         "effects": {
#             "biomedical_multiplier": 0.90,  # -10%
#             "real_estate_multiplier": 0.90  # -10%
#         }
#     },
#     7: {
#         "name": "å…¬å‘Šï¼šç¶“æ¿Ÿå¾©ç”¦<br>ï¼ˆà¸›à¸£à¸°à¸à¸²à¸¨: à¸à¸²à¸£à¸Ÿà¸·à¹‰à¸™à¸•à¸±à¸§à¸—à¸²à¸‡à¹€à¸¨à¸£à¸©à¸à¸à¸´à¸ˆï¼‰",
#         "description": "*",
#         "alert": "ğŸ“ˆ Recovery underway!",
#         "effects": {
#             "stocks_multiplier": 1.00
#         }
#     },
#     8: {
#         "name": "Announcement: Tech Boom",
#         "description": "Technology sector drives market rally",
#         "alert": "ğŸ’» Tech boom lifts all stocks!",
#         "effects": {
#             "stocks_multiplier": 1.08,
#             "etf_multiplier": 1.10
#         }
#     },
#     9: {
#         "name": "Announcement: Market Correction",
#         "description": "Profit-taking leads to market pullback",
#         "alert": "ğŸ“‰ Market correction in progress",
#         "effects": {
#             "stocks_multiplier": 0.95
#         }
#     },
#     10: {
#         "name": "Announcement: Holiday Shopping Season",
#         "description": "Consumer spending boosts retail and real estate",
#         "alert": "ğŸ„ Holiday spending boosts economy!",
#         "effects": {
#             "real_estate_multiplier": 1.08,
#             "stocks_multiplier": 1.04
#         }
#     },
#     11: {
#         "name": "Announcement: Year-End Rally",
#         "description": "Markets push higher into year-end",
#         "alert": "ğŸŠ Year-end rally begins!",
#         "effects": {
#             "stocks_multiplier": 1.05,
#             "real_estate_multiplier": 1.03
#         }
#     },
#     12: {
#         "name": "Announcement: Year-End Results",
#         "description": "Annual performance review - ETF wins!",
#         "alert": "ğŸ† Year complete! ETF outperforms!",
#         "effects": {
#             "etf_bonus": 1.02,
#             "mutual_penalty": 0.99,
#             "year_end": True
#         }
#     }
# }
# 
# def get_month_event(month):
#     """Get event for specific month"""
#     return MONTHLY_EVENTS.get(month, MONTHLY_EVENTS[1])
# 
# # ============= STOCK PRICE SCHEDULE ============
# 
# STOCK_PRICES = {
#     'biomedical': {
#         1: 100,   # Jan - Start
#         2: 160,   # Feb - Breakthrough +30%
#         3: 180,   # Mar - Interest spike -7%
#         4: 190,   # Apr - War uncertainty
#         5: 20,    # May - FRAUD! -90%
#         6: 12,    # Jun - Slight recovery
#         7: 12,    # Jul - Stabilizing
#         8: 11,    # Aug - Slow recovery
#         9: 11,    # Sep - Correction
#         10: 11,   # Oct - Holiday season
#         11: 10,   # Nov - Year-end
#         12: 7    # Dec - Final
#     },
#     'real_estate': {
#         1: 500,   # Jan - Start
#         2: 505,   # Feb - Stable
#         3: 470,   # Mar - Interest spike -7%
#         4: 541,   # Apr - War safe haven +15%
#         5: 546,   # May - Holding
#         6: 530,   # Jun - Rate cut helps
#         7: 590,   # Jul - Recovery
#         8: 610,   # Aug - Tech boom helps
#         9: 580,   # Sep - Correction
#         10: 626,  # Oct - Holiday +8%
#         11: 645,  # Nov - Rally +3%
#         12: 660   # Dec - Year-end
#     },
#     'etf_set': {
#         1: 1000,  # Jan - Base
#         2: 1015,  # Feb - Slight up
#         3: 944,   # Mar - Interest spike -7%
#         4: 953,   # Apr - War impact
#         5: 963,   # May - Biomedical small impact (diversified)
#         6: 1011,  # Jun - Rate cut +5%
#         7: 1041,  # Jul - Recovery +3%
#         8: 1124,  # Aug - Tech boom +8%
#         9: 1068,  # Sep - Correction -5%
#         10: 1111, # Oct - Holiday +4%
#         11: 1167, # Nov - Rally +5%
#         12: 1190  # Dec - Year-end +2% bonus
#     },
#     'mutual': {
#         1: 1000,  # Jan
#         2: 1010,  # Feb - Lagging ETF
#         3: 939,   # Mar - Worse than ETF
#         4: 945,   # Apr
#         5: 950,   # May
#         6: 998,   # Jun
#         7: 1028,  # Jul
#         8: 1111,  # Aug
#         9: 1055,  # Sep - Worse correction
#         10: 1094, # Oct
#         11: 1149, # Nov
#         12: 1160  # Dec - Loses to ETF
#     }
# }
# 
# def get_stock_price(stock_type, month):
#     """Get stock price for specific month"""
#     return STOCK_PRICES.get(stock_type, {}).get(month, 100)
# 
# def get_stock_history(stock_type, current_month):
#     """Get price history up to current month"""
#     months = list(range(1, current_month + 1))
#     prices = [STOCK_PRICES.get(stock_type, {}).get(m, 100) for m in months]
#     return months, prices
# 
# # Page configuration
# st.set_page_config(
#     page_title="Financialf Simulation Game",
#     layout="wide",
#     initial_sidebar_state="collapsed"
# )
# 
# # Enhanced CSS with colors, gradients, and beautiful design
# st.markdown("""
# <style>
#     @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Poppins:wght@600;800&display=swap');
# 
#     /* Global Styles */
#     * {
#         font-family: 'Noto Sans TC', 'Poppins', sans-serif;
#     }
# 
#     /* Ivory white background */
#     .stApp {
#         background: #FFFFF0;  /* Ivory white */
#     }
# 
#     /* Main content area */
#     .main .block-container {
#         padding: 2rem;
#         background: white;
#         border-radius: 20px;
#         box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
#     }
# 
#     /* All text black */
#     h1, h2, h3, p, div, span, label, .stMarkdown {
#         color: #1a1a1a !important;  /* Nearly black */
#     }
# 
#     /* Headers slightly bolder */
#     h1, h2, h3 {
#         font-family: 'Poppins', sans-serif;
#         font-weight: 700;
#     }
# 
#     h1 {
#         font-size: 2.5rem;
#     }
# 
#     .center-text {
#         text-align: center;
#     }
# 
#     /* Buttons - keep some color for visibility */
#     .stButton>button {
#         width: 100%;
#         background: #e2e8f0;  /* Light gray */
#         color: #1a1a1a !important;  /* Black text */
#         border: 2px solid #cbd5e0;
#         border-radius: 10px;
#         padding: 0.75rem 1.5rem;
#         font-size: 1rem;
#         font-weight: 600;
#         transition: all 0.2s ease;
#         cursor: pointer;
#     }
# 
#     .stButton>button:hover {
#         background: #cbd5e0;
#         border-color: #a0aec0;
#         color: #1a1a1a !important;
#     }
# 
#     /* Metric cards */
#     div[data-testid="metric-container"] {
#         background: #f7fafc;  /* Very light gray */
#         padding: 1rem;
#         border-radius: 8px;
#         border: 1px solid #e2e8f0;
#     }
# 
#     /* Info boxes */
#     .stInfo {
#         background: #ebf8ff;
#         color: #1a365d;
#         border-radius: 8px;
#         border-left: 4px solid #3182ce;
#     }
# 
#     .stSuccess {
#         background: #f0fff4;
#         color: #22543d;
#         border-radius: 8px;
#         border-left: 4px solid #38a169;
#     }
# 
#     .stWarning {
#         background: #fffaf0;
#         color: #744210;
#         border-radius: 8px;
#         border-left: 4px solid #dd6b20;
#     }
# 
#     .stError {
#         background: #fff5f5;
#         color: #742a2a;
#         border-radius: 8px;
#         border-left: 4px solid #e53e3e;
#     }
# 
#     /* Input fields */
#     .stTextInput>div>div>input, .stNumberInput>div>div>input {
#         border-radius: 8px;
#         border: 2px solid #cbd5e0;
#         padding: 0.5rem;
#         color: #1a1a1a;
#     }
# 
#     /* Month badge */
#     .month-badge {
#         background: #4a5568;
#         color: white !important;
#         padding: 0.5rem 1.5rem;
#         border-radius: 20px;
#         display: inline-block;
#         font-weight: 700;
#         box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
#     }
# 
#     /* Status badges */
#     .status-submitted {
#         background: #38a169;
#         color: white;
#         padding: 0.5rem 1rem;
#         border-radius: 8px;
#         display: inline-block;
#         font-weight: 600;
#     }
# 
#     .status-pending {
#         background: #dd6b20;
#         color: white;
#         padding: 0.5rem 1rem;
#         border-radius: 8px;
#         display: inline-block;
#         font-weight: 600;
#     }
# 
#     /* Leaderboard */
#     .leaderboard-gold {
#         background: #f6ad55;
#         color: #1a1a1a;
#         padding: 1rem;
#         border-radius: 8px;
#         margin: 0.5rem 0;
#         font-weight: 700;
#         border: 2px solid #dd6b20;
#     }
# 
#     .leaderboard-silver {
#         background: #cbd5e0;
#         color: #1a1a1a;
#         padding: 1rem;
#         border-radius: 8px;
#         margin: 0.5rem 0;
#         font-weight: 700;
#         border: 2px solid #a0aec0;
#     }
# 
#     .leaderboard-bronze {
#         background: #fc8181;
#         color: #1a1a1a;
#         padding: 1rem;
#         border-radius: 8px;
#         margin: 0.5rem 0;
#         font-weight: 700;
#         border: 2px solid #e53e3e;
#     }
# </style>
# """, unsafe_allow_html=True)
# 
# # ============= FIREBASE CONNECTION =============
# @st.cache_resource
# def init_firebase():
#     """Initialize Firebase"""
#     try:
#         if not firebase_admin._apps:
#             cred = credentials.Certificate('firebase-key.json')
#             firebase_admin.initialize_app(cred)
#         return firestore.client()
#     except Exception as e:
#         st.error(f"Firebase initialization failed: {e}")
#         st.stop()
# 
# db = init_firebase()
# 
# # ============= DATABASE FUNCTIONS =============
# 
# def get_game_state():
#     """Get game state from Firebase"""
#     try:
#         doc = db.collection('game_state').document('current').get()
#         if doc.exists:
#             data = doc.to_dict()
#             # Add missing fields if they don't exist
#             if 'interest_rate' not in data:
#                 data['interest_rate'] = 2.0
#             if 'loan_rate' not in data:
#                 data['loan_rate'] = 72.0  #this is annual
#             if 'inflation_rate' not in data:
#                 data['inflation_rate'] = 2.0
#             if 'etf_return_rate' not in data:
#                 data['etf_return_rate'] = 10.0  # Changed to 10%
#             if 'mutual_return_rate' not in data:
#                 data['mutual_return_rate'] = 10.5  # Changed to 9-12% average
#             if 'etf_fee' not in data:
#                 data['etf_fee'] = 0.24
#             if 'mutual_fee' not in data:
#                 data['mutual_fee'] = 24  # Changed to 2%
#             if 'biomedical_return_rate' not in data:
#                 data['biomedical_return_rate'] = 15
#             if 'real_estate_return_rate' not in data:
#                 data['real_estate_return_rate'] = 7
#             db.collection('game_state').document('current').set(data, merge=True)
#             return data
#         else:
#             default_state = {
#                 'current_month': 1,
#                 'exact_cost_daily': 4000,
#                 'exact_cost_food': 4000,
#                 'interest_rate': 2.0,
#                 'loan_rate': 72.0,  # Monthly rate
#                 'inflation_rate': 2.0,
#                 'etf_return_rate': 10.0,  # 10% annual
#                 'mutual_return_rate': 10.5,  # 9-12% average
#                 'mutual_return_is_variable': True,
#                 'etf_fee': 0.24,
#                 'mutual_fee': 24,  # 2% annual
#                 'biomedical_return_rate': 15,
#                 'real_estate_return_rate': 7.0,
#                 'updated_at': datetime.now()
#             }
#             db.collection('game_state').document('current').set(default_state)
#             return default_state
#     except Exception as e:
#         st.error(f"Error getting game state: {e}")
#         return {
#             'current_month': 1,
#             'exact_cost_daily': 4000,
#             'exact_cost_food': 4000,
#             'interest_rate': 2.0,
#             'loan_rate': 6.0,
#             'inflation_rate': 2.0,
#             'etf_return_rate': 10.0,
#             'mutual_return_rate': 10.5,
#             'etf_fee': 0.3,
#             'mutual_fee': 2.0,
#             'biomedical_return_rate': 15,
#             'real_estate_return_rate': 7.0,
#         }
# 
# def update_game_state(updates):
#     """Update game state"""
#     try:
#         updates['updated_at'] = datetime.now()
#         db.collection('game_state').document('current').update(updates)
#         st.cache_data.clear()
#         return True
#     except Exception as e:
#         st.error(f"Error updating game state: {e}")
#         return False
# 
# @st.cache_data(ttl=5)
# def get_all_players_cached():
#     """Get all players from Firebase with caching"""
#     try:
#         players_ref = db.collection('players')
#         docs = players_ref.stream()
# 
#         players = {}
#         for doc in docs:
#             data = doc.to_dict()
#             players[doc.id] = data
# 
#         return players
#     except Exception as e:
#         st.error(f"Error getting players: {e}")
#         return {}
# 
# def get_all_players():
#     """Get all players"""
#     return get_all_players_cached()
# 
# def get_player_data(group_name):
#     """Get specific player"""
#     try:
#         doc = db.collection('players').document(group_name).get()
#         if doc.exists:
#             return doc.to_dict()
#         return None
#     except Exception as e:
#         st.error(f"Error getting player: {e}")
#         return None
# def save_transaction(group_name, transaction_data):
#     """Save transaction to accounting ledger"""
#     try:
#         transaction_data['group_name'] = group_name
#         transaction_data['timestamp'] = datetime.now()
#         db.collection('transactions').add(transaction_data)
#         return True
#     except Exception as e:
#         return False
# 
# def get_transactions(group_name, month=None):
#     """Get transactions for a player"""
#     try:
#         query = db.collection('transactions').where('group_name', '==', group_name)
#         if month:
#             query = query.where('month', '==', month)
# 
#         # Don't order by - it requires Firestore index
#         docs = query.stream()
# 
#         transactions = []
#         for doc in docs:
#             data = doc.to_dict()
#             transactions.append(data)
# 
#         # Sort in Python instead
#         transactions.sort(key=lambda x: x.get('timestamp', datetime.now()), reverse=True)
# 
#         return transactions
#     except Exception as e:
#         print(f"Transaction error: {e}")
#         return []
# 
# def get_monthly_summary(group_name, month):
#     """Calculate P&L for a specific month"""
#     transactions = get_transactions(group_name, month)
# 
#     income = sum(t['amount'] for t in transactions if t['type'] in ['Income', 'Investment Gain', 'Interest Earned'])
#     expenses = sum(t['amount'] for t in transactions if t['type'] in ['Expense', 'Fee', 'Interest Paid', 'Investment Loss'])
# 
#     return {
#         'income': income,
#         'expenses': expenses,
#         'net': income - expenses,
#         'transactions': transactions
#     }
# 
# def update_player_data(group_name, data):
#     """Update or create player data"""
#     try:
#         data['updated_at'] = datetime.now()
#         db.collection('players').document(group_name).set(data, merge=True)
#         st.cache_data.clear()
#         return True
#     except Exception as e:
#         st.error(f"Error updating player: {e}")
#         return False
# 
# def get_lottery_results(month):
#     """Get lottery results"""
#     try:
#         docs = db.collection('lottery_results').where('month', '==', month).stream()
#         results = {}
#         for doc in docs:
#             data = doc.to_dict()
#             results[data['group_name']] = {
#                 'won': data['won'],
#                 'prize': data['prize']
#             }
#         return results
#     except Exception as e:
#         return {}
# 
# def save_lottery_result(group_name, month, won, prize):
#     """Save lottery result"""
#     try:
#         db.collection('lottery_results').add({
#             'group_name': group_name,
#             'month': month,
#             'won': won,
#             'prize': prize,
#             'timestamp': datetime.now()
#         })
#         return True
#     except Exception as e:
#         return False
# 
# def delete_all_players():
#     """Delete all player data (for reset)"""
#     try:
#         players_ref = db.collection('players')
#         docs = players_ref.stream()
#         for doc in docs:
#             doc.reference.delete()
# 
#         # Delete lottery results too
#         lottery_ref = db.collection('lottery_results')
#         docs = lottery_ref.stream()
#         for doc in docs:
#             doc.reference.delete()
# 
#         return True
#     except Exception as e:
#         st.error(f"Error deleting players: {e}")
#         return False
# 
# def delete_all_transactions():
#     """Delete all transactions (for game reset)"""
#     try:
#         docs = db.collection('transactions').stream()
#         for doc in docs:
#             doc.reference.delete()
#         return True
#     except Exception as e:
#         print(f"Error deleting transactions: {e}")
#         return False
# 
# def apply_monthly_event(month, game_state, all_players):
#     """Apply automatic monthly event"""
#     event = get_month_event(month)
#     effects = event.get('effects', {})
# 
#     event_log = {
#         'month': month,
#         'event_name': event['name'],
#         'effects_applied': []
#     }
# 
#     # Update game state rates
#     if 'interest_rate_change' in effects:
#         new_rate = game_state['interest_rate'] + effects['interest_rate_change']
#         game_state['interest_rate'] = max(0.1, new_rate)
#         event_log['effects_applied'].append(f"Savings rate: {new_rate}%")
# 
#     if 'loan_rate_change' in effects:
#         new_loan_rate = game_state['loan_rate'] + effects['loan_rate_change']
#         game_state['loan_rate'] = max(0.5, new_loan_rate)
#         event_log['effects_applied'].append(f"Loan rate: {new_loan_rate}%")
# 
#     if 'inflation_change' in effects:
#         game_state['inflation_rate'] += effects['inflation_change']
#         event_log['effects_applied'].append(f"Inflation: {game_state['inflation_rate']}%")
# 
#     if 'expense_multiplier' in effects:
#         game_state['exact_cost_daily'] = int(game_state['exact_cost_daily'] * effects['expense_multiplier'])
#         event_log['effects_applied'].append(f"Daily expense: \${game_state['exact_cost_daily']}")
# 
#     if 'food_multiplier' in effects:
#         game_state['exact_cost_food'] = int(game_state['exact_cost_food'] * effects['food_multiplier'])
#         event_log['effects_applied'].append(f"Food cost: \${game_state['exact_cost_food']}")
# 
#     # Apply to all players
#     for group_name, data in all_players.items():
#         player_effects = []
# 
#         # Biomedical stock effect
#         if 'biomedical_multiplier' in effects and data.get('biomedical', 0) > 0:
#             old_value = data['biomedical']
#             data['biomedical'] = int(old_value * effects['biomedical_multiplier'])
#             change = data['biomedical'] - old_value
#             player_effects.append(f"ç”Ÿé†«æ–°å‰µ: \${change:+,}")
# 
#             save_transaction(group_name, {
#                 'type': 'Investment Gain' if change > 0 else 'Investment Loss',
#                 'amount': abs(change),
#                 'description': f"Biomedical stock {event['name']}",
#                 'month': month
#             })
# 
#         # Real estate effect
#         if 'real_estate_multiplier' in effects and data.get('real_estate', 0) > 0:
#             old_value = data['real_estate']
#             data['real_estate'] = int(old_value * effects['real_estate_multiplier'])
#             change = data['real_estate'] - old_value
#             player_effects.append(f"Real Estate: \${change:+,}")
# 
#             save_transaction(group_name, {
#                 'type': 'Investment Gain' if change > 0 else 'Investment Loss',
#                 'amount': abs(change),
#                 'description': f"Real estate {event['name']}",
#                 'month': month
#             })
# 
# 
# 
#         #é€™è£¡å¥½åƒä¸æ˜¯å¾ˆé‡è¦ï¼Œåªè¦è¨­å®šetf, mutual priceç®—éå°±å¥½
#         # ETF vs Mutual Fund year-end
#         if effects.get('etf_bonus') and data.get('fund', 0) > 0:
#             if data.get('fund_type') == 'etf':
#                 bonus = int(data['fund'] * (effects['etf_bonus'] - 1))
#                 data['fund'] += bonus
#                 data['total_asset'] += bonus
#                 player_effects.append(f"ETF year-end bonus: +\${bonus:,}")
# 
#         if effects.get('mutual_penalty') and data.get('fund', 0) > 0:
#             if data.get('fund_type') == 'mutual':
#                 penalty = int(data['fund'] * (1 - effects['mutual_penalty']))
#                 data['fund'] -= penalty
#                 data['total_asset'] -= penalty
#                 player_effects.append(f"Mutual fund: -\${penalty:,}")
# 
#         # Update player
#         if player_effects:
#             data['last_event_effects'] = player_effects
# 
#     # Clear the skip_next_income flag after processing, this causing skip income only affecting one player and move on
#     if game_state.get('skip_next_income', False):
#         update_game_state({'skip_next_income': False})
# 
# 
# 
#     # Update game state
#     update_game_state(game_state)
# 
#     return event, event_log
# 
# ###############Snapshot section###########
# def take_monthly_snapshot(group_name, player_data, game_state):
#     """Take a snapshot of player's current allocation"""
#     snapshot = {
#         'group_name': group_name,
#         'month': game_state['current_month'],
#         'timestamp': datetime.now(),
# 
#         # Cash & Loan
#         'total_asset': player_data['total_asset'],
#         'savings': player_data.get('savings', 0),
#         'loan_balance': player_data.get('loan_balance', 0),
# 
#         # Investments (values)
#         'etf': player_data.get('etf', 0),
#         'mutual': player_data.get('mutual', 0),
#         'biomedical': player_data.get('biomedical', 0),
#         'real_estate': player_data.get('real_estate', 0),
# 
#         # Shares (quantities)
#         'etf_shares': player_data.get('etf_shares', 0),
#         'mutual_shares': player_data.get('mutual_shares', 0),
#         'biomedical_shares': player_data.get('biomedical_shares', 0),
#         'real_estate_shares': player_data.get('real_estate_shares', 0),
# 
#         # Prices at this month
#         'etf_price': get_stock_price('etf_set', game_state['current_month']),
#         'mutual_price': get_stock_price('mutual', game_state['current_month']),
#         'biomedical_price': get_stock_price('biomedical', game_state['current_month']),
#         'real_estate_price': get_stock_price('real_estate', game_state['current_month']),
# 
#         # Net worth calculation
#         'net_worth': (
#             player_data['total_asset'] +
#             player_data.get('etf', 0) +
#             player_data.get('mutual', 0) +
#             player_data.get('biomedical', 0) +
#             player_data.get('real_estate', 0) -
#             player_data.get('loan_balance', 0)
#         )
#     }
# 
#     try:
#         db.collection('monthly_snapshots').add(snapshot)
#         return True
#     except Exception as e:
#         print(f"Error saving snapshot: {e}")
#         return False
# 
# def get_player_snapshots(group_name):
#     """Get all snapshots for a player"""
#     try:
#         docs = db.collection('monthly_snapshots')\
#             .where('group_name', '==', group_name)\
#             .order_by('month')\
#             .stream()
# 
#         snapshots = []
#         for doc in docs:
#             snapshots.append(doc.to_dict())
#         return snapshots
#     except Exception as e:
#         print(f"Error getting snapshots: {e}")
#         return []
# 
# def delete_all_snapshots():
#     """Delete all snapshots (for game reset)"""
#     try:
#         docs = db.collection('monthly_snapshots').stream()
#         for doc in docs:
#             doc.reference.delete()
#         return True
#     except Exception as e:
#         print(f"Error deleting snapshots: {e}")
#         return False
# # ============= SESSION STATE ============
# # ============= CALCULATION FUNCTIONS =============
# 
# #é€™è£¡ä¹Ÿæ˜¯
# def calculate_simple_interest(principal, annual_rate, months=1):
#     """Calculate simple interest"""
#     return principal * (annual_rate / 100) * (months / 12)
# 
# def calculate_compound_interest(principal, annual_rate, months=1):
#     """Calculate compound interest (monthly compounding)"""
#     monthly_rate = annual_rate / 100 / 12
#     amount = principal * ((1 + monthly_rate) ** months)
#     return amount - principal
# #é€™è£¡ä¹Ÿæ˜¯
# def calculate_monthly_simple_interest(principal, annual_rate):
#     """Simple interest for one month"""
#     return principal * (annual_rate / 100 / 12)
# 
# def calculate_monthly_compound_interest(principal, annual_rate):
#     """Compound interest for one month with DAILY compounding"""
#     daily_rate = annual_rate / 100 / 365
#     days_in_month = 30
#     # Compound daily for 30 days: P * [(1 + r)^30 - 1]
#     return principal * ((1 + daily_rate) ** days_in_month - 1)
# 
# def calculate_fund_fee(fund_amount, annual_fee_rate):
#     """Calculate monthly fund management fee"""
#     return fund_amount * (annual_fee_rate / 100 / 12)
# 
# def calculate_fund_return(fund_amount, annual_return_rate):
#     """Calculate monthly fund return"""
#     return fund_amount * (annual_return_rate / 100 / 12)
# 
# def calculate_loan_interest(loan_balance, annual_rate):
#     """Calculate monthly loan interest"""
#     return loan_balance * (annual_rate / 100 / 12)
# 
# 
# 
# 
# 
# 
# # ============= SESSION STATE =============
# 
# if 'page' not in st.session_state:
#     st.session_state.page = 'home'
# if 'group_name' not in st.session_state:
#     st.session_state.group_name = ''
# if 'is_admin' not in st.session_state:
#     st.session_state.is_admin = False
# 
# MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
# 
# def get_current_month_name():
#     game_state = get_game_state()
#     return MONTHS[(game_state['current_month'] - 1) % 12]
# 
# # ============= HOME PAGE =============
# 
# def home_page():
#     st.markdown("<h1 class='center-text' style='font-size: 3.5rem; text-shadow: 3px 3px 6px rgba(0,0,0,0.3);'>ä¸€æ–°æŠ•è³‡ç†è²¡éŠæˆ²</h1>", unsafe_allow_html=True)
#     st.markdown("<p class='center-text' style='font-size: 1.3rem; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);'>Money doesn't buy happiness, it buys crazy ass hapiness - Eminem.</p>", unsafe_allow_html=True)
# 
#     st.markdown("<br><br>", unsafe_allow_html=True)
# 
#     col1, col2, col3 = st.columns([1, 2, 1])
# 
#     with col2:
#         st.markdown("<div class='emoji-decor'>ğŸ‘¨â€ğŸ’¼</div>", unsafe_allow_html=True)
#         if st.button("ğŸ¯ ç®¡ç†å“¡ à¹à¸­à¸”à¸¡à¸´à¸™", use_container_width=True):
#             st.session_state.page = 'admin_login'
#             st.rerun()
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         st.markdown("<div class='emoji-decor'>ğŸ“</div>", unsafe_allow_html=True)
#         if st.button("ğŸš€ å­¸ç”Ÿ à¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™", use_container_width=True):
#             st.session_state.page = 'student_login'
#             st.rerun()
# 
# # ============= ADMIN LOGIN =============
# 
# def admin_login_page():
#     st.markdown("<div class='emoji-decor'>ğŸ”</div>", unsafe_allow_html=True)
#     st.markdown("<h1 class='center-text'>Administrator Login</h1>", unsafe_allow_html=True)
# 
#     col1, col2, col3 = st.columns([1, 1, 1])
# 
#     with col2:
#         password = st.text_input("ğŸ”‘ Enter Admin Password", type="password", key="admin_password")
# 
#         if st.button("ğŸšª ç™»å…¥", use_container_width=True):
#             if password == "admin123":
#                 st.session_state.is_admin = True
#                 st.session_state.page = 'admin_dashboard'
#                 st.success("âœ… Login successful!")
#                 time.sleep(0.5)
#                 st.rerun()
#             else:
#                 st.error("âŒ Incorrect password!")
# 
#         if st.button("â† è¿”å›é¦–é ï¼ˆà¸à¸¥à¸±à¸šà¸ªà¸¹à¹ˆà¸«à¸™à¹‰à¸²à¹à¸£à¸ï¼‰", use_container_width=True):
#             st.session_state.page = 'home'
#             st.rerun()
# 
# # ============= STUDENT LOGIN =============
# 
# def student_login_page():
#     st.markdown("<div class='emoji-decor'>ğŸ“ğŸ‘¥ğŸ’¼</div>", unsafe_allow_html=True)
#     st.markdown("<h1 class='center-text'>æ­¡è¿! ç²¾æ˜çš„æŠ•è³‡è€…å€‘<br>à¸¢à¸´à¸™à¸”à¸µà¸•à¹‰à¸­à¸™à¸£à¸±à¸šà¸™à¸±à¸à¸¥à¸‡à¸—à¸¸à¸™à¸œà¸¹à¹‰à¸Šà¸²à¸à¸‰à¸¥à¸²à¸”à¸—à¸¸à¸à¸—à¹ˆà¸²à¸™</h1>", unsafe_allow_html=True)
#     st.markdown("<h3 class='center-text' style='color: #667eea;'>é¸æ“‡éšŠå(ä¸å¯åŒ…å«ç©ºç™½éµ)<br>à¹€à¸¥à¸·à¸­à¸à¸Šà¸·à¹ˆà¸­à¸—à¸µà¸¡ (à¸«à¹‰à¸²à¸¡à¸¡à¸µà¸Šà¹ˆà¸­à¸‡à¸§à¹ˆà¸²à¸‡)</h3>", unsafe_allow_html=True)
# 
#     col1, col2, col3 = st.columns([1, 1, 1])
# 
#     with col2:
#         group_name = st.text_input("ä½ çš„éšŠåï¼ˆà¸Šà¸·à¹ˆà¸­à¸—à¸µà¸¡à¸‚à¸­à¸‡à¸„à¸¸à¸“ï¼‰", key="group_name_input", placeholder="e.g., Money Masters")
# 
#         if st.button("ğŸš€ é–‹å§‹ä½ çš„æ—…ç¨‹ï¼ˆà¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸à¸²à¸£à¹€à¸”à¸´à¸™à¸—à¸²à¸‡à¸‚à¸­à¸‡à¸„à¸¸à¸“ï¼‰", use_container_width=True):
#             if group_name.strip():
#                 st.session_state.group_name = group_name.strip()
#                 st.session_state.is_admin = False
# 
#                 existing_data = get_player_data(group_name)
#                 if not existing_data:
#                     game_state = get_game_state()
#                     new_player_data = {
#                         'total_asset': 30000,
#                         'month': game_state['current_month'],
# 
#                         # Investments
#                         'savings': 30000,
#                         'savings_type': 'simple',
#                         'etf': 0,              # â† NEW: Separate ETF
#                         'etf_shares': 0,       # â† NEW
#                         'mutual': 0,           # â† NEW: Separate Mutual
#                         'mutual_shares': 0,    # â† NEW
#                         'biomedical': 0,
#                         'biomedical_shares': 0,
#                         'real_estate': 0,
#                         'real_estate_shares': 0,  # NEW: Track shares
# 
#                         # Loan
#                         'loan_balance': 0,
#                         'loan_interest_paid': 0,
# 
#                         #Lottery
#                         'lottery_history': [],
# 
#                         # Expenses
#                         'exact_cost_daily': game_state['exact_cost_daily'],
#                         'exact_cost_food': game_state['exact_cost_food'],
# 
#                         # Status
#                         'is_broke': False,
#                         'submitted': False,
# 
#                         # History
#                         'history': {
#                             'months': [],
#                             'total_assets': [],
#                             'savings': [],
#                             'fund': [],
#                             'biomedical': [],
#                             'real_estate': [],
#                             'loan': [],
#                             'net_worth': []
#                         }
#                     }
# 
#                     update_player_data(group_name, new_player_data)
# 
#                 st.session_state.page = 'student_game'
#                 st.success(f"âœ… Welcome, {group_name}!")
#                 time.sleep(0.5)
#                 st.rerun()
#             else:
#                 st.error("âš ï¸ Please enter a team name!")
# 
#         if st.button("â† è¿”å›é¦–é ï¼ˆà¸à¸¥à¸±à¸šà¸ªà¸¹à¹ˆà¸«à¸™à¹‰à¸²à¹à¸£à¸ï¼‰", use_container_width=True):
#             st.session_state.page = 'home'
#             st.rerun()
# 
# # ============= STUDENT GAME PAGE =============
# 
# def student_game_page():
#     group_name = st.session_state.group_name
#     player_data = get_player_data(group_name)
#     game_state = get_game_state()
# 
#     # ========== INITIALIZE SESSION STATE FOR ALL INPUTS ==========
#     if 'inv_loan' not in st.session_state:
#         st.session_state.inv_loan = 0
#     if 'lottery_amount' not in st.session_state:
#         st.session_state.lottery_amount = 0
#     if 'etf_action' not in st.session_state:
#         st.session_state.etf_action = 'Hold'
#     if 'etf_shares_input' not in st.session_state:
#         st.session_state.etf_shares_input = 0
#     if 'mutual_action' not in st.session_state:
#         st.session_state.mutual_action = 'Hold'
#     if 'mutual_shares_input' not in st.session_state:
#         st.session_state.mutual_shares_input = 0
#     if 'bio_action' not in st.session_state:
#         st.session_state.bio_action = 'Hold'
#     if 'bio_shares_input' not in st.session_state:
#         st.session_state.bio_shares_input = 0
#     if 're_action' not in st.session_state:
#         st.session_state.re_action = 'Hold'
#     if 're_shares_input' not in st.session_state:
#         st.session_state.re_shares_input = 0
#     if 'show_confirm' not in st.session_state:
#         st.session_state.show_confirm = False
# 
#     # Get current month for pricing
#     current_month = game_state['current_month']
# 
#     if not player_data:
#         st.error("âŒ Player data not found. Please login again.")
#         return
# 
#     if player_data.get('is_broke', False):
#         st.markdown("<h1 class='center-text' style='color: #e53e3e;'>ä½ ç ´ç”¢äº†! éŠæˆ²çµæŸ</h1>", unsafe_allow_html=True)
#         st.markdown("<p class='center-text'>Don't give up! Learn from this experience!</p>", unsafe_allow_html=True)
#         return
# 
#     # Add this near the top of student_game_page(), after the header
#     col_header1, col_header2, col_header3 = st.columns([2, 1, 1])
# 
#     with col_header1:
#         st.markdown(f"<h2 class='center-text'>Welcome Back, {group_name}!</h2>", unsafe_allow_html=True)
#         # ... existing code ...
# 
#     with col_header2:
#         st.markdown(f"<div class='month-badge'>ğŸ“… Month: {get_current_month_name()}</div>", unsafe_allow_html=True)
# 
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # ========== WAITING ROOM (ONLY FOR SUBMITTED PLAYERS) ==========
#     if player_data.get('submitted', False):
#         st.markdown(f"<h1 class='center-text'>Waiting Room</h1>", unsafe_allow_html=True)
#         st.markdown(f"<h2 class='center-text' style='color: white;'>Hello, {group_name}!</h2>", unsafe_allow_html=True)
# 
#         st.info("âœ… å·²æ”¶åˆ°ä½ çš„æäº¤ï¼æ­£åœ¨ç­‰å¾…ç®¡ç†å“¡æ¨é€²åˆ°ä¸‹å€‹æœˆâ€¦â€¦ï¼ˆà¹„à¸”à¹‰à¸£à¸±à¸šà¸à¸²à¸£à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸‚à¸­à¸‡à¸„à¸¸à¸“à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§! à¸à¸³à¸¥à¸±à¸‡à¸£à¸­à¸œà¸¹à¹‰à¸”à¸¹à¹à¸¥à¸£à¸°à¸šà¸šà¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£à¹„à¸›à¸¢à¸±à¸‡à¹€à¸”à¸·à¸­à¸™à¸–à¸±à¸”à¹„à¸›â€¦ï¼‰")
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
# 
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         # ========== SHOW JANUARY RESULTS ==========
#         st.markdown("### ğŸ“Š æœ¬æœˆæ‘˜è¦ï¼ˆà¸ªà¸£à¸¸à¸›à¸œà¸¥à¸‚à¸­à¸‡à¹€à¸”à¸·à¸­à¸™à¸™à¸µà¹‰ï¼‰")
# 
#         # Show current month allocation (now with 7 columns for loan and lottery)
#         col1, col2, col3, col4, col5, col6, col7 = st.columns(7)
# 
#         with col1:
#             st.metric("ğŸ¦ Savings", f"${player_data.get('savings', 0):,.0f}")
# 
#         with col2:
#             etf_value = player_data.get('etf', 0)
#             etf_shares = player_data.get('etf_shares', 0)
#             st.metric("ğŸ“ˆ ETF tracks SET Index", f"{etf_shares} shares")
#             if etf_shares > 0:
#                 st.caption(f"(${etf_value:,.0f})")
# 
#         with col3:
#             mutual_value = player_data.get('mutual', 0)
#             mutual_shares = player_data.get('mutual_shares', 0)
#             st.metric("ğŸ“Š å…±åŒåŸºé‡‘ï¼ˆà¸à¸­à¸‡à¸—à¸¸à¸™à¸£à¸§à¸¡ï¼‰", f"{mutual_shares} shares")
#             if mutual_shares > 0:
#                 st.caption(f"(${mutual_value:,.0f})")
# 
#         with col4:
#             bio_shares = player_data.get('biomedical_shares', 0)
#             st.metric("ğŸ§¬ ç”Ÿé†«æ–°å‰µå…¬å¸ï¼ˆà¸ªà¸•à¸²à¸£à¹Œà¸—à¸­à¸±à¸à¸”à¹‰à¸²à¸™à¸Šà¸µà¸§à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œï¼‰", f"{bio_shares} shares")
#             if bio_shares > 0:
#                 st.caption(f"(${player_data.get('biomedical', 0):,.0f})")
# 
#         with col5:
#             re_shares = player_data.get('real_estate_shares', 0)
#             st.metric("ğŸ  æ™®é­¯å…‹è–©ä¸å‹•ç”¢ï¼ˆà¸à¸¤à¸à¸©à¸² à¹€à¸£à¸µà¸¢à¸¥à¹€à¸­à¸ªà¹€à¸•à¸—ï¼‰", f"{re_shares} shares")
#             if re_shares > 0:
#                 st.caption(f"(${player_data.get('real_estate', 0):,.0f})")
# 
#         with col6:
#             # Show loan as metric
#             if player_data.get('loan_balance', 0) > 0:
#                 st.metric("ğŸ’³ Loan", f"${player_data['loan_balance']:,.0f}")
#             else:
#                 st.metric("ğŸ’³ Loan", "$0")
# 
#         with col7:
#             # Find lottery result
#             lottery_history = player_data.get('lottery_history', [])
# 
#             this_month_lottery = None
#             for record in lottery_history:
#                 if record['month'] == current_month:
#                     this_month_lottery = record
#                     break
# 
#             # Show lottery as metric
#             if this_month_lottery:
#                 if this_month_lottery['won']:
#                     profit = this_month_lottery['prize'] - this_month_lottery['stake']
#                     st.metric("ğŸ° Lottery",
#                              f"WON ${this_month_lottery['prize']:,.0f}",
#                              delta=f"+${profit:,.0f}")
#                 else:
#                     st.metric("ğŸ° Lottery",
#                              f"LOST",
#                              delta=f"-${this_month_lottery['stake']:,.0f}",
#                              delta_color="inverse")
#             else:
#                 st.metric("ğŸ° Lottery", "No bet")
# 
#         # ========== LOTTERY RESULT DETAILS ==========
#         if this_month_lottery:
#             col_lot1, col_lot2 = st.columns(2)
# 
#             with col_lot1:
#                 st.caption(f"ğŸ° Lottery Stake: ${this_month_lottery['stake']:,.0f}")
# 
#             with col_lot2:
#                 if this_month_lottery['won']:
#                     profit = this_month_lottery['prize'] - this_month_lottery['stake']
#                     st.success(f"ğŸ‰ WON ${this_month_lottery['prize']:,.0f} (Profit: +${profit:,.0f})")
#                 else:
#                     st.error(f"ğŸ’¸ LOST ${this_month_lottery['stake']:,.0f}")
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         # ========== THIS MONTH RESULT ==========
#         st.markdown("### ğŸ’° æœ¬æœˆçµæœï¼ˆà¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œà¸‚à¸­à¸‡à¹€à¸”à¸·à¸­à¸™à¸™à¸µà¹‰ï¼‰")
# 
# 
#         col_r1, col_r2, col_r3, col_r4 = st.columns(4)
# 
#         # Calculate expected returns
#         expected_income = 10000
#         expected_expenses = player_data.get('exact_cost_daily', 0) + player_data.get('exact_cost_food', 0)
# 
#         # Savings interest
#         savings_interest = 0
#         if player_data.get('savings', 0) > 0:
#             savings_interest = calculate_monthly_compound_interest(
#                 player_data['savings'],
#                 game_state['interest_rate']
#             )
# 
#         # ETF fees
#         etf_fee = 0
#         if player_data.get('etf', 0) > 0:
#             etf_fee = calculate_fund_fee(player_data['etf'], game_state.get('etf_fee', 0.3))
# 
#         # Mutual fees
#         mutual_fee = 0
#         if player_data.get('mutual', 0) > 0:
#             mutual_fee = calculate_fund_fee(player_data['mutual'], game_state.get('mutual_fee', 2.0))
# 
#         # Stock returns
#         bio_return = 0
#         if player_data.get('biomedical', 0) > 0:
#             bio_return = calculate_fund_return(player_data['biomedical'], game_state.get('biomedical_return_rate', 15.0))
# 
#         re_return = 0
#         if player_data.get('real_estate', 0) > 0:
#             re_return = calculate_fund_return(player_data['real_estate'], game_state.get('real_estate_return_rate', 7.0))
# 
#         # Loan interest
#         loan_interest = 0
#         if player_data.get('loan_balance', 0) > 0:
#             loan_interest = calculate_loan_interest(player_data['loan_balance'], game_state['loan_rate'])
# 
#         with col_r1:
#             st.success(f"ğŸ’µ Income: +${expected_income:,.2f} (next month)")
#             if savings_interest > 0:
#                 st.success(f"ğŸ¦ å„²è“„ à¸à¸²à¸£à¸­à¸­à¸¡à¹€à¸‡à¸´à¸™: +${savings_interest:,.2f}")
#             if bio_return > 0:
#                 st.success(f"ğŸ§¬ Bio: +${bio_return:,.2f}")
#             if re_return > 0:
#                 st.success(f"ğŸ  RE: +${re_return:,.2f}")
# 
#         with col_r2:
#             st.error(f"ğŸ  æ—¥å¸¸é–‹éŠ·ï¼ˆà¸„à¹ˆà¸²à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢à¸›à¸£à¸°à¸ˆà¸³à¸§à¸±à¸™ï¼‰: -${expected_expenses:,.2f}")
#             if etf_fee > 0:
#                 st.error(f"ğŸ’³ ETF Fee: -${etf_fee:,.2f}")
#             if mutual_fee > 0:
#                 st.error(f"ğŸ’³ Mutual Fee: -${mutual_fee:,.2f}")
#             if loan_interest > 0:
#                 st.error(f"ğŸ’³ è²¸æ¬¾ï¼ˆà¹€à¸‡à¸´à¸™à¸à¸¹à¹‰ï¼‰: -${loan_interest:,.2f}")
# 
#         with col_r4:
#             # Calculate ONLY liquid cash changes (NO price changes!)
#             next_month_savings = (player_data['total_asset'] +
#                                 expected_income +
#                                 savings_interest +
#                                 bio_return +
#                                 re_return -
#                                 etf_fee -
#                                 mutual_fee -
#                                 loan_interest)
# 
#             st.metric("ğŸ’° ä¸‹å€‹æœˆå„²è“„ï¼ˆà¹€à¸‡à¸´à¸™à¸­à¸­à¸¡à¸‚à¸­à¸‡à¹€à¸”à¸·à¸­à¸™à¸–à¸±à¸”à¹„à¸›ï¼‰", f"${next_month_savings:,.0f}")
#             st.caption("ï¼ˆå¯å‹•ç”¨ç¾é‡‘ï¼‰ï¼ˆà¹€à¸‡à¸´à¸™à¸ªà¸”à¸—à¸µà¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢à¹„à¸”à¹‰ï¼‰")
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         # ========== SHOW PRICE PREVIEW ==========
#         next_month = min(current_month + 1, 12)
#         if current_month < 12:
#             st.markdown("### ğŸ“ˆ ä¸‹å€‹æœˆè‚¡åƒ¹é è¦½ï¼ˆà¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡à¸£à¸²à¸„à¸²à¸«à¸¸à¹‰à¸™à¸‚à¸­à¸‡à¹€à¸”à¸·à¸­à¸™à¸–à¸±à¸”à¹„à¸›ï¼‰")
#             col_p1, col_p2 = st.columns(2)
# 
#             with col_p1:
#                 bio_current = get_stock_price('biomedical', current_month)
#                 bio_next = get_stock_price('biomedical', next_month)
#                 bio_pct = ((bio_next - bio_current) / bio_current * 100)
# 
#                 st.markdown("**ğŸ§¬ ç”Ÿé†«æ–°å‰µ:**")
#                 st.write(f"Current: ${bio_current} â†’ Next: ${bio_next}")
#                 if bio_pct > 0:
#                     st.success(f"Change: +{bio_pct:.1f}%")
#                 else:
#                     st.error(f"Change: {bio_pct:.1f}%")
# 
#             with col_p2:
#                 re_current = get_stock_price('real_estate', current_month)
#                 re_next = get_stock_price('real_estate', next_month)
#                 re_pct = ((re_next - re_current) / re_current * 100)
# 
#                 st.markdown("**ğŸ  Pruksa Real Estateï¼ˆà¸à¸¤à¸à¸©à¸² à¹€à¸£à¸µà¸¢à¸¥à¹€à¸­à¸ªà¹€à¸•à¸—ï¼‰:**")
#                 st.write(f"Current: ${re_current} â†’ Next: ${re_next}")
#                 if re_pct > 0:
#                     st.success(f"Change: +{re_pct:.1f}%")
#                 else:
#                     st.error(f"Change: {re_pct:.1f}%")
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
# 
# 
#         # ========== CHECK IF ADMIN ADVANCED MONTH ==========
#         fresh_player_data = get_player_data(group_name)
#         fresh_game_state = get_game_state()
# 
#         # Only check if month advanced (don't check submitted flag to avoid loop)
#         if fresh_player_data.get('month', 0) < fresh_game_state['current_month']:
#             st.success("ğŸ‰ Admin has advanced to the next month!")
#             st.cache_data.clear()
#             time.sleep(1)
#             st.rerun()
#         # ========== VIEW ACCOUNTING BUTTON (MOVED HERE, ABOVE REFRESH) ==========
#         if st.button("ğŸ“Š æŸ¥çœ‹äº¤æ˜“ç´€éŒ„ï¼ˆà¸”à¸¹à¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸à¸²à¸£à¸—à¸³à¸˜à¸¸à¸£à¸à¸£à¸£à¸¡ï¼‰", use_container_width=True, key="accounting_waiting"):
#             st.session_state.page = 'student_accounting'
#             st.rerun()
# 
#         # Refresh button for WAITING ROOM
#         if st.button("ğŸ”„ æ›´æ–°ç‹€æ…‹ï¼ˆà¸£à¸µà¹€à¸Ÿà¸£à¸Šà¸ªà¸–à¸²à¸™à¸°ï¼‰", use_container_width=True):
#             st.cache_data.clear()
#             st.rerun()
# 
#         return  # Exit function - don't show allocation page
# 
#     # ========== ALLOCATION PAGE (FOR PLAYERS WHO HAVEN'T SUBMITTED) ==========
#     # Show refresh timer and button
#     if 'last_refresh' not in st.session_state:
#         st.session_state.last_refresh = time.time()
# 
#     time_since_refresh = int(time.time() - st.session_state.last_refresh)
# 
#     col_info, col_refresh = st.columns([3, 1])
#     with col_info:
#         st.caption(f"â° Last updated: {time_since_refresh}s ago")
#     with col_refresh:
#         if st.button("ğŸ”„ Refresh Now", use_container_width=True, key="manual_refresh"):
#             st.session_state.last_refresh = time.time()
#             st.cache_data.clear()
#             st.rerun()
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
# 
# 
#     # Show current interest rates
#     st.markdown("### ğŸ’¹ å¸‚å ´ç‹€æ…‹ à¸ªà¸ à¸²à¸§à¸°à¸•à¸¥à¸²à¸”")
#     col_rate1, col_rate2, col_rate3, col_rate4 = st.columns(4)
#     with col_rate1:
#         st.info(f"ğŸ¦ å„²è“„ à¸à¸²à¸£à¸­à¸­à¸¡à¹€à¸‡à¸´à¸™: {game_state['interest_rate']:.1f}% annual")
#     with col_rate2:
#         st.info(f"ğŸ’³ è²¸æ¬¾ï¼ˆà¹€à¸‡à¸´à¸™à¸à¸¹à¹‰ï¼‰: {game_state['loan_rate']:.1f}% annual")
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Expense section
#     st.markdown("<h2 style='text-align: center; color: white;'>æ¯æœˆæ”¯å‡ºï¼ˆà¸£à¸²à¸¢à¸ˆà¹ˆà¸²à¸¢à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰</h2>", unsafe_allow_html=True)
# 
#     col1, col2 = st.columns(2)
# 
#     exact_cost_daily = player_data.get('exact_cost_daily', game_state['exact_cost_daily'])
#     exact_cost_food = player_data.get('exact_cost_food', game_state['exact_cost_food'])
# 
#     with col1:
#         st.markdown("### ğŸ  æ—¥å¸¸ç”Ÿæ´»ï¼ˆà¸à¸²à¸£à¹ƒà¸Šà¹‰à¸Šà¸µà¸§à¸´à¸•à¸›à¸£à¸°à¸ˆà¸³à¸§à¸±à¸™ï¼‰")
#         st.number_input("Amount ($)", value=exact_cost_daily, disabled=True, key="daily_exp")
#         daily_percentage = (exact_cost_daily / player_data['total_asset'] * 100) if player_data['total_asset'] > 0 else 0
# 
# 
#     with col2:
#         st.markdown("### ğŸ” é£²é£Ÿï¼ˆà¸­à¸²à¸«à¸²à¸£ï¼‰")
#         st.number_input("Amount ($)", value=exact_cost_food, disabled=True, key="food_exp")
#         food_percentage = (exact_cost_food / player_data['total_asset'] * 100) if player_data['total_asset'] > 0 else 0
# 
# 
#     # After expenses
#     total_fixed_expenses = exact_cost_daily + exact_cost_food
#     remaining_for_investment = player_data['total_asset'] - total_fixed_expenses
#     # ========== ADD THIS: SHOW STEP 1 ==========
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     st.markdown(f"<h3 style='text-align: center; color: #1a1a1a;'>1ï¸âƒ£ æ”¯å‡ºå¾Œï¼ˆà¸«à¸¥à¸±à¸‡à¸«à¸±à¸à¸„à¹ˆà¸²à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢ï¼‰: ${remaining_for_investment:,.0f}</h3>", unsafe_allow_html=True)
#     st.markdown("<br>", unsafe_allow_html=True)
#     # ... rest of allocation page continues here ...
#     # ========== Initialize all investment variables ==========
#     # These need to be set before calculating savings
#     if 'inv_etf' not in locals():
#         inv_etf = 0
#     if 'inv_mutual' not in locals():
#         inv_mutual = 0
#     if 'inv_biomedical' not in locals():
#         inv_biomedical = 0
#     if 'inv_real_estate' not in locals():
#         inv_real_estate = 0
#     if 'etf_share_change' not in locals():
#         etf_share_change = 0
#     if 'mutual_share_change' not in locals():
#         mutual_share_change = 0
#     if 'bio_share_change' not in locals():
#         bio_share_change = 0
#     if 're_share_change' not in locals():
#         re_share_change = 0
# 
#     # Now calculate total invested
#     total_invested = (
#         abs(inv_etf) +
#         abs(inv_mutual) +
#         abs(inv_biomedical) +
#         abs(inv_real_estate)
#     )
# 
#     # ========== LOAN SECTION ==========
#     st.markdown("### ğŸ’³ è²¸æ¬¾ï¼ˆà¹€à¸‡à¸´à¸™à¸à¸¹à¹‰ï¼‰")
#     col_loan1, col_loan2, col_loan3 = st.columns([2, 1, 1])
# 
#     with col_loan1:
#         max_loan = int(player_data['total_asset'] * 0.5) - player_data.get('loan_balance', 0)
#         if max_loan > 0:
#             inv_loan = st.number_input(
#                 "Borrow Amount ($)",
#                 min_value=0,
#                 max_value=max_loan,
#                 value=st.session_state.inv_loan,  # â† Use session state
#                 step=1000,
#                 key="loan_input"
#             )
#             st.session_state.inv_loan = inv_loan  # â† Save back to session state
#             st.caption(f"ğŸ’¡ Max borrowing: ${max_loan:,.0f} (50% of assets)")
#         else:
#             st.info("You've reached max loan capacity (50% of assets)")
#             inv_loan = 0
#             st.session_state.inv_loan = 0
# 
#     with col_loan2:
#       annual_loan_rate = game_state['loan_rate']  # 72% annual
#       monthly_loan_rate = annual_loan_rate / 12   # 6% monthly
#       total_loan_balance = player_data.get('loan_balance', 0) + inv_loan
#       monthly_loan_interest = calculate_loan_interest(total_loan_balance, game_state['loan_rate'])
# 
#       st.metric("Monthly Rate", f"{monthly_loan_rate:.1f}%")  # â† Shows 6.0%
#       st.caption(f"({annual_loan_rate:.0f}% annual)")
#       if total_loan_balance > 0:
#           st.caption(f"â‰ˆ ${monthly_loan_interest:,.2f}/month")
# 
#     with col_loan3:
#         if inv_loan > 0:
#             monthly_payment = inv_loan * (monthly_loan_rate / 100 / 12)
#             st.metric("New Loan Interest", f"${monthly_payment:,.2f}")
#             st.warning("âš ï¸ Must repay!")
# 
#     # ADD LOAN TO AVAILABLE MONEY
#     remaining_for_investment += inv_loan  # â† FIX: Now loan can be used!
# 
#     st.markdown(f"<h3 style='text-align: center; color: white;'>2ï¸âƒ£ åŠ å…¥è²¸æ¬¾å¾Œï¼ˆà¸«à¸¥à¸±à¸‡à¹€à¸à¸´à¹ˆà¸¡à¹€à¸‡à¸´à¸™à¸à¸¹à¹‰ï¼‰: ${remaining_for_investment:,.0f}</h3>", unsafe_allow_html=True)
#     # ========== END LOAN SECTION ==========
# 
#     # ========== LOTTERY SECTION ==========
#     st.markdown("<br>", unsafe_allow_html=True)
#     st.markdown("### ğŸ° **æ¯æœˆå½©åˆ¸ï¼ˆé¸å¡«ï¼‰ï¼ˆà¸¥à¸­à¸•à¹€à¸•à¸­à¸£à¸µà¹ˆà¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ (à¹„à¸¡à¹ˆà¸šà¸±à¸‡à¸„à¸±à¸š)ï¼‰**")
# 
#     col_lot1, col_lot2 = st.columns([2, 1])
# 
#     with col_lot1:
#         st.info( "ğŸ² **æ©Ÿç‡ï¼ˆà¸„à¸§à¸²à¸¡à¸™à¹ˆà¸²à¸ˆà¸°à¹€à¸›à¹‡à¸™ï¼‰ï¼š**\n" "- **10% æ©Ÿç‡ï¼š** ç²å¾— 130%ï¼ˆæ¯æŠ•å…¥ $100 å¯æ‹¿å› $130ï¼‰\n" "- **1% æ©Ÿç‡ï¼š** ç²å¾— 200%ï¼ˆæ¯æŠ•å…¥ $100 å¯æ‹¿å› $200ï¼‰" )
# 
#         # Calculate max lottery - ensure it's non-negative
#         max_lottery = max(0, int(remaining_for_investment))
# 
#         if max_lottery > 0:
#             lottery_amount = st.number_input(
#                 "Lottery Amount ($)",
#                 min_value=0,
#                 max_value=max_lottery,
#                 value=min(st.session_state.lottery_amount, max_lottery),  # â† Use session state
#                 step=100,
#                 key="lottery_input"  # â† Keep this one
#             )
#             st.session_state.lottery_amount = lottery_amount  # â† Save back
# 
#             if lottery_amount > 0:
#                 st.warning(f"âš ï¸ You're betting \${lottery_amount:,.0f}")
#         else:
#             st.error("âŒ Not enough funds for lottery!")
#             lottery_amount = 0
#             st.session_state.lottery_amount = 0
# 
#     with col_lot2:
#         # Show lottery history
#         lottery_history = player_data.get('lottery_history', [])
# 
# 
#         if lottery_history:
#             st.markdown("#### ğŸ“œ å½©åˆ¸äº¤æ˜“ç´€éŒ„ï¼ˆà¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸à¸²à¸£à¸—à¸³à¸£à¸²à¸¢à¸à¸²à¸£à¸¥à¸­à¸•à¹€à¸•à¸­à¸£à¸µà¹ˆï¼‰")
# 
#             # Show last 3 results
#             for i, record in enumerate(reversed(lottery_history[-3:])):
#                 month_name = MONTHS[record['month'] - 1] if record['month'] <= 12 else f"M{record['month']}"
#                 if record['won']:
#                     st.success(f"{month_name}: +\${record['prize']:,.0f} ğŸ‰")
#                 else:
#                     st.error(f"{month_name}: -\${record['stake']:,.0f} ğŸ’¸")
# 
#             # Calculate total
#             total_won = sum(r['prize'] for r in lottery_history if r['won'])
#             total_lost = sum(r['stake'] for r in lottery_history if not r['won'])
#             net = total_won - total_lost
# 
#             if net > 0:
#                 st.success(f"**Net: +\${net:,.0f}**")
#             else:
#                 st.error(f"**Net: \${net:,.0f}**")
#         else:
#             st.caption("ç›®å‰å°šç„¡å½©åˆ¸ç´€éŒ„ï¼ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µà¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸¥à¸­à¸•à¹€à¸•à¸­à¸£à¸µà¹ˆï¼‰")
# 
#     #Deduct lottery from available funds
#     remaining_for_investment -= lottery_amount
# 
#     st.markdown("<br>", unsafe_allow_html=True)
#     st.markdown(f"<h2 style='text-align: center; color: white;'>3ï¸âƒ£ å¯æŠ•è³‡é‡‘é¡ï¼ˆà¹€à¸‡à¸´à¸™à¸—à¸µà¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸™à¸³à¹„à¸›à¸¥à¸‡à¸—à¸¸à¸™à¹„à¸”à¹‰ï¼‰: ${remaining_for_investment:,.0f}</h2>", unsafe_allow_html=True)
# 
#     if remaining_for_investment < 0:
#         st.error("âš ï¸ ä½ çš„æ”¯å‡ºå·²è¶…éä½ çš„ç¸½è³‡ç”¢ï¼ä½ å¯èƒ½éœ€è¦è²¸æ¬¾ï¼Œå¦å‰‡å°‡æœƒç ´ç”¢ï¼<br>ï¼ˆà¸„à¹ˆà¸²à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢à¸‚à¸­à¸‡à¸„à¸¸à¸“à¸ªà¸¹à¸‡à¸à¸§à¹ˆà¸²à¸ªà¸´à¸™à¸—à¸£à¸±à¸à¸¢à¹Œà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”! à¸„à¸¸à¸“à¸­à¸²à¸ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™à¸•à¹‰à¸­à¸‡à¸à¸¹à¹‰à¹€à¸‡à¸´à¸™ à¸¡à¸´à¸‰à¸°à¸™à¸±à¹‰à¸™à¸­à¸²à¸ˆà¸¥à¹‰à¸¡à¸¥à¸°à¸¥à¸²à¸¢à¹„à¸”à¹‰!ï¼‰!")
# 
#     # ========== INVESTMENT SECTION ==========
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Row 1: Savings (with interest type choice)
#     st.markdown("### ğŸ¦ å„²è“„ï¼ˆà¸à¸²à¸£à¸­à¸­à¸¡à¹€à¸‡à¸´à¸™ï¼‰")
#     col_sav1, col_sav2 = st.columns([2, 1])
# 
#     with col_sav1:
#         savings_type = st.radio(
#             "Interest Type:",
#             ["è¤‡åˆ©ï¼ˆà¸”à¸­à¸à¹€à¸šà¸µà¹‰à¸¢à¸—à¸šà¸•à¹‰à¸™ï¼‰"],
#             horizontal=True,
#             key="savings_type_choice"
#         )
# 
#         # Show comparison with specific calculations
#         if remaining_for_investment > 0:
#             annual_rate = game_state['interest_rate']
# 
#             # Simple interest calculation: P Ã— r Ã— t
#             simple_monthly_rate = annual_rate / 12
#             simple_interest = remaining_for_investment * (simple_monthly_rate / 100)
# 
#             # Compound interest calculation: P Ã— ((1 + r)^t - 1)
#             compound_monthly_rate = annual_rate / 100 / 12
#             compound_interest = remaining_for_investment * compound_monthly_rate
# 
#             st.info(f"ğŸ’¡ With ${remaining_for_investment:,.0f} at {annual_rate:.1f}% annual:\n\n"
#                    f"**Simple Interest:**\n"
#                    f"  å…¬å¼ï¼š æœ¬é‡‘ Ã— ({annual_rate:.1f}% Ã· 12)\n"
#                    f"  = \${remaining_for_investment:,.0f} Ã— {simple_monthly_rate:.3f}%\n"
#                    f"  = \${simple_interest:,.2f}/month\n\n"
#                    f"**Compound Interest:**\n"
#                    f"  å…¬å¼ï¼š æœ¬é‡‘ Ã— [(1 + {annual_rate:.1f}%/12)Â¹ - 1]\n"
#                    f"  = \${remaining_for_investment:,.0f} Ã— {compound_monthly_rate:.4f}\n"
#                    f"  = \${compound_interest:,.2f}/month")
# 
#     with col_sav2:
#         annual_rate = game_state['interest_rate']
# 
#         if savings_type == "Simple Interest":
#             monthly_rate = annual_rate / 12
#             st.metric("Monthly Rate", f"{monthly_rate:.3f}%")
#             st.caption(f"({annual_rate:.1f}% annual)")
#             st.caption("ğŸ“Š Simple calculation")
#         else:
#             monthly_rate = annual_rate / 12
#             st.metric("Monthly Rate", f"{monthly_rate:.3f}%")
#             st.caption(f"({annual_rate:.1f}% annual)")
#             st.caption("ğŸ“ˆ Compounds monthly")
# 
#     # Row 2: Fund (ETF AND Mutual - can buy both!)
#     st.markdown("### ğŸ“ˆ åŸºé‡‘ï¼ˆà¸à¸­à¸‡à¸—à¸¸à¸™ï¼‰")
# 
#     # Get current fund holdings
#     current_etf_shares = player_data.get('etf_shares', 0)
#     current_etf_value = player_data.get('etf', 0)
#     current_mutual_shares = player_data.get('mutual_shares', 0)
#     current_mutual_value = player_data.get('mutual', 0)
# 
#     # Get current fund prices
#     etf_price = get_stock_price('etf_set', current_month)
#     mutual_price = get_stock_price('mutual', current_month)
# 
#     tab_etf, tab_mutual = st.tabs(["ğŸ“ˆ ETF tracks SET Index", "ğŸ“Š å…±åŒåŸºé‡‘ï¼ˆà¸à¸­à¸‡à¸—à¸¸à¸™à¸£à¸§à¸¡ï¼‰"])
# 
#     with tab_etf:
#       st.markdown("#### ğŸ“Š ETF tracks SET Index")
# 
#       etf_share_change = 0  # Default value
#       inv_etf = 0
# 
#       col_etf1, col_etf2, col_etf3 = st.columns([2, 1, 1])
# 
#       with col_etf1:
#           st.markdown(f"### ğŸ’µ Current Price: ${etf_price}/ä¸€è‚¡")
# 
#           if current_etf_shares > 0:
#               st.info(f"ğŸ“Š Holdings: {current_etf_shares} shares (${current_etf_value:,.0f})")
#           else:
#               st.info(f"ğŸ“Š Holdings: 0 shares")
# 
#           # ETF action radio
#           action = st.radio(
#               "Action:",
#               ["Hold", "Buy", "Sell"],
#               horizontal=True,
#               key="etf_action_radio",
#               index=["Hold", "Buy", "Sell"].index(st.session_state.etf_action)
#           )
#           st.session_state.etf_action = action
# 
#           if action == "Buy":
#               # â† CALCULATE max_shares HERE, BEFORE using it
#               max_shares = int(remaining_for_investment / etf_price) if etf_price > 0 else 0
# 
#               shares_to_buy = st.number_input(
#                   "Shares to Buy",
#                   min_value=0,
#                   max_value=max_shares,  # â† NOW it's defined
#                   value=min(st.session_state.etf_shares_input, max_shares),
#                   step=1,
#                   key="etf_buy"
#               )
#               st.session_state.etf_shares_input = shares_to_buy
#               inv_etf = shares_to_buy * etf_price
#               etf_share_change = shares_to_buy
# 
#               if shares_to_buy > 0:
#                   st.success(f"â• Buying {shares_to_buy} shares = ${inv_etf:,.0f}")
# 
#           elif action == "Sell":
#               shares_to_sell = st.number_input(
#                   "Shares to Sell",
#                   min_value=0,
#                   max_value=current_etf_shares,
#                   value=min(st.session_state.etf_shares_input, current_etf_shares),
#                   step=1,
#                   key="etf_sell"
#               )
#               st.session_state.etf_shares_input = shares_to_sell
#               inv_etf = -shares_to_sell * etf_price
#               etf_share_change = -shares_to_sell
#               if shares_to_sell > 0:
#                   st.warning(f"â– Selling {shares_to_sell} shares = +${abs(inv_etf):,.0f} cash")
# 
#           else:  # Hold
#               inv_etf = 0
#               etf_share_change = 0
#               st.session_state.etf_shares_input = 0
#               st.success(f"âœ“ Holding {current_etf_shares} shares (${current_etf_value:,.0f})")
# 
#           with col_etf2:
#               monthly_fee_rate = game_state['etf_fee'] / 12
#               monthly_fee_amount = current_etf_value * (monthly_fee_rate / 100) if current_etf_value > 0 else 0
#               st.metric("æœˆè²»ï¼ˆà¸„à¹ˆà¸²à¸˜à¸£à¸£à¸¡à¹€à¸™à¸µà¸¢à¸¡à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰", f"{monthly_fee_rate:.3f}%")
#               st.caption(f"â‰ˆ ${monthly_fee_amount:,.2f}/month")  # â† SHOW DOLLAR AMOUNT
#               st.caption("âœ… Low cost")
# 
#           with col_etf3:
#               if current_etf_value > 0:
#                   monthly_fee = calculate_fund_fee(current_etf_value, game_state['etf_fee'])
#                   st.metric("Fee Cost", f"${monthly_fee:,.2f}")
# 
#     # ========== MUTUAL TAB ==========
#     with tab_mutual:
#         st.markdown("#### ğŸ“Š å…±åŒåŸºé‡‘ï¼ˆà¸à¸­à¸‡à¸—à¸¸à¸™à¸£à¸§à¸¡ï¼‰")
# 
#         mutual_share_change = 0
#         inv_mutual = 0
# 
#         col_mut1, col_mut2, col_mut3 = st.columns([2, 1, 1])
# 
#     with col_mut1:
#         st.markdown(f"### ğŸ’µ Current Price: ${mutual_price}/ä¸€è‚¡")
# 
#         if current_mutual_shares > 0:
#             st.info(f"ğŸ“Š Holdings: {current_mutual_shares} shares (${current_mutual_value:,.0f})")
#         else:
#             st.info(f"ğŸ“Š Holdings: 0 shares")
# 
#         action = st.radio(
#             "Action:",
#             ["Hold", "Buy", "Sell"],
#             horizontal=True,
#             key="mutual_action_radio",
#             index=["Hold", "Buy", "Sell"].index(st.session_state.mutual_action)  # â† Preserve
#         )
#         st.session_state.mutual_action = action  # â† Save back
# 
#         if action == "Buy":
#             max_shares = int(remaining_for_investment / mutual_price) if mutual_price > 0 else 0
#             shares_to_buy = st.number_input(
#                 "Shares to Buy",
#                 min_value=0,
#                 max_value=max_shares,
#                 value=min(st.session_state.mutual_shares_input, max_shares),  # â† Preserve (capped)
#                 step=1,
#                 key="mutual_buy"
#             )
#             st.session_state.mutual_shares_input = shares_to_buy  # â† Save back
#             inv_mutual = shares_to_buy * mutual_price
#             mutual_share_change = shares_to_buy
#             if shares_to_buy > 0:
#                 st.success(f"â• Buying {shares_to_buy} shares = ${inv_mutual:,.0f}")
#         elif action == "Sell":
#             shares_to_sell = st.number_input(
#                 "Shares to Sell",
#                 min_value=0,
#                 max_value=current_mutual_shares,
#                 value=min(st.session_state.mutual_shares_input, current_mutual_shares),  # â† Preserve (capped)
#                 step=1,
#                 key="mutual_sell"
#             )
#             st.session_state.mutual_shares_input = shares_to_sell  # â† Save back
#             inv_mutual = -shares_to_sell * mutual_price
#             mutual_share_change = -shares_to_sell
#             if shares_to_sell > 0:
#                 st.warning(f"â– Selling {shares_to_sell} shares = +${abs(inv_mutual):,.0f} cash")
#         else:  # Hold
#             inv_mutual = 0
#             mutual_share_change = 0
#             st.session_state.mutual_shares_input = 0  # â† Reset when holding
#             st.success(f"âœ“ Holding {current_mutual_shares} shares (${current_mutual_value:,.0f})")
# 
#         with col_mut2:
#             monthly_fee_rate = game_state['mutual_fee'] / 12
#             monthly_fee_amount = current_mutual_value * (monthly_fee_rate / 100) if current_mutual_value > 0 else 0
#             st.metric("æœˆè²»ï¼ˆà¸„à¹ˆà¸²à¸˜à¸£à¸£à¸¡à¹€à¸™à¸µà¸¢à¸¡à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰", f"{monthly_fee_rate:.2f}%")
#             st.caption(f"â‰ˆ ${monthly_fee_amount:,.2f}/month")  # â† SHOW DOLLAR AMOUNT
#             st.caption("âš ï¸ Higher fee")
# 
#         with col_mut3:
#             if current_mutual_value > 0:
#                 monthly_fee = calculate_fund_fee(current_mutual_value, game_state['mutual_fee'])
#                 st.metric("Fee Cost", f"${monthly_fee:,.2f}")
# 
#     # Show fund history (keep existing code)
#     st.markdown("---")
#     st.markdown("#### ğŸ“Š åŸºé‡‘åƒ¹æ ¼æ­·å²ç´€éŒ„ï¼ˆà¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸£à¸²à¸„à¸²à¸à¸­à¸‡à¸—à¸¸à¸™ï¼‰")
# 
#     # ... keep existing fund history code ...
#     if current_month >= 1:
#             # Create fund performance table
#             fund_data = []
#             for month in range(1, current_month + 1):
#                 etf_price = get_stock_price('etf_set', month)
#                 mutual_price = get_stock_price('mutual', month)
# 
#                 etf_prev = get_stock_price('etf_set', month - 1) if month > 1 else 1000
#                 mutual_prev = get_stock_price('mutual', month - 1) if month > 1 else 1000
# 
#                 etf_change = etf_price - etf_prev
#                 mutual_change = mutual_price - mutual_prev
# 
#                 etf_change_pct = (etf_change / etf_prev * 100) if etf_prev > 0 else 0
#                 mutual_change_pct = (mutual_change / mutual_prev * 100) if mutual_prev > 0 else 0
# 
#                 fund_data.append({
#                     'Month': MONTHS[month - 1],
#                     'ETF Price': f'\${etf_price}',
#                     'ETF Change': f'\${etf_change:+.0f}' if month > 1 else '-',
#                     'ETF (%)': f'{etf_change_pct:+.1f}%' if month > 1 else '-',
#                     'Mutual Price': f'\${mutual_price}',
#                     'Mutual Change': f'\${mutual_change:+.0f}' if month > 1 else '-',
#                     'Mutual (%)': f'{mutual_change_pct:+.1f}%' if month > 1 else '-'
#                 })
# 
#             # Display table
#             import pandas as pd
#             df = pd.DataFrame(fund_data)
#             st.dataframe(df, use_container_width=True, hide_index=True)
# 
#             # Show comparison chart
#             months_list = list(range(1, current_month + 1))
#             month_names = [MONTHS[m - 1] for m in months_list]
# 
#             etf_values = [get_stock_price('etf_set', m) for m in months_list]
#             mutual_values = [get_stock_price('mutual', m) for m in months_list]
# 
#             fig = go.Figure()
# 
#             fig.add_trace(go.Scatter(
#                 x=month_names,
#                 y=etf_values,
#                 mode='lines+markers',
#                 name='ETF tracks SET Index',
#                 line=dict(color='#48bb78', width=3),
#                 marker=dict(size=8),
#                 text=[f'\${v}' for v in etf_values],
#                 hovertemplate='<b>ETF tracks SET Index</b><br>%{x}<br>Price: $%{y}<extra></extra>'
#             ))
# 
#             fig.add_trace(go.Scatter(
#                 x=month_names,
#                 y=mutual_values,
#                 mode='lines+markers',
#                 name='Mutual Fund',
#                 line=dict(color='#f093fb', width=3),
#                 marker=dict(size=8),
#                 text=[f'\${v}' for v in mutual_values],
#                 hovertemplate='<b>Mutual Fund</b><br>%{x}<br>Price: $%{y}<extra></extra>'
#             ))
# 
#             fig.update_layout(
#                 title="Fund Performance Comparison (Base: $1,000)",
#                 xaxis_title="Month",
#                 yaxis_title="Value ($)",
#                 height=350,
#                 hovermode='x unified',
#                 margin=dict(l=10, r=10, t=40, b=10),
#                 legend=dict(
#                     orientation="h",
#                     yanchor="bottom",
#                     y=1.02,
#                     xanchor="right",
#                     x=1
#                 )
#             )
# 
#             st.plotly_chart(fig, use_container_width=True, key="fund_comparison_chart")
# 
#             # Show which is winning
#             etf_current = get_stock_price('etf_set', current_month)
#             mutual_current = get_stock_price('mutual', current_month)
# 
#             if etf_current > mutual_current:
#                 diff = etf_current - mutual_current
#                 diff_pct = ((etf_current / mutual_current - 1) * 100)
#                 st.success(f"âœ… ETF tracks SET Index is ahead by \${diff:,.0f} ({diff_pct:+.1f}%)")
#             elif mutual_current > etf_current:
#                 diff = mutual_current - etf_current
#                 diff_pct = ((mutual_current / etf_current - 1) * 100)
#                 st.info(f"ğŸ“Š å…±åŒåŸºé‡‘ï¼ˆà¸à¸­à¸‡à¸—à¸¸à¸™à¸£à¸§à¸¡ï¼‰ is ahead by \${diff:,.0f} ({diff_pct:+.1f}%)")
#             else:
#                 st.info("ğŸ“Š Both funds are currently tied")
#     else:  # â† MOVE THIS UP TO MATCH THE OUTER if current_month >= 1
#       st.info("ğŸ“ŠåŸºé‡‘åƒ¹æ ¼æ­·å²ç´€éŒ„å°‡è‡ªç¬¬ 2 å€‹æœˆèµ·é¡¯ç¤ºï¼ˆà¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸£à¸²à¸„à¸²à¸à¸­à¸‡à¸—à¸¸à¸™à¸ˆà¸°à¹à¸ªà¸”à¸‡à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆà¹€à¸”à¸·à¸­à¸™à¸—à¸µà¹ˆ 2 à¹€à¸›à¹‡à¸™à¸•à¹‰à¸™à¹„à¸›ï¼‰")
# 
#         # ========== END OF FUND HISTORY ==========
# 
# 
#     # Row 4: Stocks with Buy/Sell functionality and Simplified Price History
#     st.markdown("### ğŸ“Š è‚¡å¸‚ï¼ˆà¸•à¸¥à¸²à¸”à¸«à¸¸à¹‰à¸™ï¼‰")
# 
#     # ========== DEFINE THESE VARIABLES BEFORE THE TABS ==========
#     current_bio_shares = player_data.get('biomedical_shares', 0)
#     current_bio_value = player_data.get('biomedical', 0)
#     current_re_shares = player_data.get('real_estate_shares', 0)
#     current_re_value = player_data.get('real_estate', 0)
# 
#     # Initialize variables
#     inv_biomedical = 0
#     bio_share_change = 0
#     inv_real_estate = 0
#     re_share_change = 0
# 
#     # NOW create the tabs
#     tab1, tab2 = st.tabs(["ğŸ§¬ ç”Ÿé†«æ–°å‰µå…¬å¸ï¼ˆà¸ªà¸•à¸²à¸£à¹Œà¸—à¸­à¸±à¸à¸”à¹‰à¸²à¸™à¸Šà¸µà¸§à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œï¼‰", "ğŸ  Pruksa Real Estateï¼ˆà¸à¸¤à¸à¸©à¸² à¹€à¸£à¸µà¸¢à¸¥à¹€à¸­à¸ªà¹€à¸•à¸—ï¼‰"])
# 
#     with tab1:
#         # Get current stock price
#         biomedical_price = get_stock_price('biomedical', current_month)
# 
#         # Show price history TABLE (simplified)
#         st.markdown("#### ğŸ“Š Price History")
# 
#         if current_month >= 1:
#             # Create price history table
#             price_data = []
#             for month in range(1, current_month + 1):
#                 price = get_stock_price('biomedical', month)
#                 prev_price = get_stock_price('biomedical', month - 1) if month > 1 else price
#                 change = price - prev_price
#                 change_pct = (change / prev_price * 100) if prev_price > 0 else 0
# 
#                 price_data.append({
#                     'Month': MONTHS[month - 1],
#                     'Stock Price': f'\${price}',
#                     'Change': f'\${change:+.0f}' if month > 1 else '-',
#                     'Change (%)': f'{change_pct:+.1f}%' if month > 1 else '-'
#                 })
# 
#             # Display table
#             import pandas as pd
#             df = pd.DataFrame(price_data)
#             st.dataframe(df, use_container_width=True, hide_index=True)
# 
#             # Show price chart with exact values on hover
#             months_list = list(range(1, current_month + 1))
#             prices_list = [get_stock_price('biomedical', m) for m in months_list]
#             month_names = [MONTHS[m - 1] for m in months_list]
# 
#             fig = go.Figure()
#             fig.add_trace(go.Scatter(
#                 x=month_names,
#                 y=prices_list,
#                 mode='lines+markers',
#                 name='Biomedical',
#                 line=dict(color='#f5576c', width=3),
#                 marker=dict(size=10),
#                 text=[f'\${p}' for p in prices_list],
#                 hovertemplate='<b>%{x}</b><br>Price: $%{y}<br><extra></extra>'
#             ))
#             fig.update_layout(
#                 title="Biomedical Stock Price",
#                 xaxis_title="Month",
#                 yaxis_title="Price per Share ($)",
#                 height=300,
#                 showlegend=False,
#                 hovermode='x unified',
#                 margin=dict(l=10, r=10, t=40, b=10)
#             )
#             st.plotly_chart(fig, use_container_width=True, key="bio_chart")
#         else:
#             st.info("ğŸ“Š Price history will show from Month 2 onwards")
# 
#         st.markdown("---")
# 
#         col_bio1, col_bio2, col_bio3 = st.columns([2, 1, 1])
# 
#     with col_bio1:
#         st.markdown(f"### ğŸ’µ Current Price: ${biomedical_price}/ä¸€è‚¡")
# 
#         if current_bio_shares > 0:
#             current_value = current_bio_shares * biomedical_price
#             st.info(f"ğŸ“Š Holdings: {current_bio_shares} shares (${current_value:,.0f})")
# 
#         action = st.radio(
#             "Action:",
#             ["Hold", "Buy", "Sell"],
#             horizontal=True,
#             key="bio_action_radio",
#             index=["Hold", "Buy", "Sell"].index(st.session_state.bio_action)  # â† Preserve
#         )
#         st.session_state.bio_action = action  # â† Save back
# 
#         if action == "Buy":
#             max_shares = int(remaining_for_investment / biomedical_price) if biomedical_price > 0 else 0
#             shares_to_buy = st.number_input(
#                 "Shares to Buy",
#                 min_value=0,
#                 max_value=max_shares,
#                 value=min(st.session_state.bio_shares_input, max_shares),  # â† Preserve (capped)
#                 step=1,
#                 key="bio_buy"
#             )
#             st.session_state.bio_shares_input = shares_to_buy  # â† Save back
#             inv_biomedical = shares_to_buy * biomedical_price
#             bio_share_change = shares_to_buy
#             if shares_to_buy > 0:
#                 st.success(f"â• Buying {shares_to_buy} shares = ${inv_biomedical:,.0f}")
#         elif action == "Sell":
#             shares_to_sell = st.number_input(
#                 "Shares to Sell",
#                 min_value=0,
#                 max_value=current_bio_shares,
#                 value=min(st.session_state.bio_shares_input, current_bio_shares),  # â† Preserve (capped)
#                 step=1,
#                 key="bio_sell"
#             )
#             st.session_state.bio_shares_input = shares_to_sell  # â† Save back
#             inv_biomedical = -shares_to_sell * biomedical_price
#             bio_share_change = -shares_to_sell
#             if shares_to_sell > 0:
#                 st.warning(f"â– Selling {shares_to_sell} shares = +${abs(inv_biomedical):,.0f} cash")
#         else:  # Hold
#             inv_biomedical = 0
#             bio_share_change = 0
#             st.session_state.bio_shares_input = 0  # â† Reset when holding
#             st.success(f"âœ“ Holding {current_bio_shares} shares (${current_bio_shares * biomedical_price:,.0f})")
# 
#         with col_bio2:
#           monthly_rate = game_state.get('biomedical_return_rate', 180.0) / 12
#           st.metric("è‚¡åˆ©ï¼ˆæ¯æœˆï¼‰ï¼ˆà¹€à¸‡à¸´à¸™à¸›à¸±à¸™à¸œà¸¥à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰", f"{monthly_rate:.1f}%")  # Shows 15.0%
#           st.caption(f"({game_state.get('biomedical_return_rate', 180.0):.0f}% annual)")
# 
# 
#         with col_bio3:
#             if current_bio_value > 0:
#               monthly_return = calculate_fund_return(current_bio_value, game_state.get('biomedical_return_rate', 180.0))
#               st.metric("é æœŸè‚¡åˆ©ï¼ˆæ¯æœˆï¼‰ï¼ˆà¹€à¸‡à¸´à¸™à¸›à¸±à¸™à¸œà¸¥à¸—à¸µà¹ˆà¸„à¸²à¸”à¸§à¹ˆà¸²à¸ˆà¸°à¹„à¸”à¹‰à¸£à¸±à¸šà¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰", f"${monthly_return:,.2f}")
# 
#     with tab2:
#       # Get current stock price
#       real_estate_price = get_stock_price('real_estate', current_month)
# 
#       # Show price history TABLE (simplified)
#       st.markdown("#### ğŸ“Š Price History")
# 
#       if current_month >= 1:
#           # Create price history table
#           price_data = []
#           for month in range(1, current_month + 1):
#               price = get_stock_price('real_estate', month)
#               prev_price = get_stock_price('real_estate', month - 1) if month > 1 else price
#               change = price - prev_price
#               change_pct = (change / prev_price * 100) if prev_price > 0 else 0
# 
#               price_data.append({
#                   'Month': MONTHS[month - 1],
#                   'Stock Price': f'\${price}',
#                   'Change': f'\${change:+.0f}' if month > 1 else '-',
#                   'Change (%)': f'{change_pct:+.1f}%' if month > 1 else '-'
#               })
# 
#           # Display table
#           import pandas as pd
#           df = pd.DataFrame(price_data)
#           st.dataframe(df, use_container_width=True, hide_index=True)
# 
#           # Show price chart with exact values on hover
#           months_list = list(range(1, current_month + 1))
#           prices_list = [get_stock_price('real_estate', m) for m in months_list]
#           month_names = [MONTHS[m - 1] for m in months_list]
# 
#           fig = go.Figure()
#           fig.add_trace(go.Scatter(
#               x=month_names,
#               y=prices_list,
#               mode='lines+markers',
#               name='Real Estate',
#               line=dict(color='#4facfe', width=3),
#               marker=dict(size=10),
#               text=[f'\${p}' for p in prices_list],
#               hovertemplate='<b>%{x}</b><br>Price: $%{y}<br><extra></extra>'
#           ))
#           fig.update_layout(
#               title="Pruksa Real Estate Stock Price",
#               xaxis_title="Month",
#               yaxis_title="Price per Share ($)",
#               height=300,
#               showlegend=False,
#               hovermode='x unified',
#               margin=dict(l=10, r=10, t=40, b=10)
#           )
#           st.plotly_chart(fig, use_container_width=True, key="re_chart")
#       else:
#           st.info("ğŸ“Š Price history will show from Month 2 onwards")
# 
#       st.markdown("---")
# 
#       col_re1, col_re2, col_re3 = st.columns([2, 1, 1])
# 
#       with col_re1:
#           st.markdown(f"### ğŸ’µ Current Price: ${real_estate_price}/ä¸€è‚¡")
# 
#           if current_re_shares > 0:
#               current_value = current_re_shares * real_estate_price
#               st.info(f"ğŸ“Š Holdings: {current_re_shares} shares (${current_value:,.0f})")
# 
#           action = st.radio(
#               "Action:",
#               ["Hold", "Buy", "Sell"],
#               horizontal=True,
#               key="re_action_radio",
#               index=["Hold", "Buy", "Sell"].index(st.session_state.re_action)  # â† Preserve
#           )
#           st.session_state.re_action = action  # â† Save back
# 
#           if action == "Buy":
#               max_shares = int(remaining_for_investment / real_estate_price) if real_estate_price > 0 else 0
#               shares_to_buy = st.number_input(
#                   "Shares to Buy",
#                   min_value=0,
#                   max_value=max_shares,
#                   value=min(st.session_state.re_shares_input, max_shares),  # â† Preserve (capped)
#                   step=1,
#                   key="re_buy"
#               )
#               st.session_state.re_shares_input = shares_to_buy  # â† Save back
#               inv_real_estate = shares_to_buy * real_estate_price
#               re_share_change = shares_to_buy
#               if shares_to_buy > 0:
#                   st.success(f"â• Buying {shares_to_buy} shares = ${inv_real_estate:,.0f}")
#           elif action == "Sell":
#               shares_to_sell = st.number_input(
#                   "Shares to Sell",
#                   min_value=0,
#                   max_value=current_re_shares,
#                   value=min(st.session_state.re_shares_input, current_re_shares),  # â† Preserve (capped)
#                   step=1,
#                   key="re_sell"
#               )
#               st.session_state.re_shares_input = shares_to_sell  # â† Save back
#               inv_real_estate = -shares_to_sell * real_estate_price
#               re_share_change = -shares_to_sell
#               if shares_to_sell > 0:
#                   st.warning(f"â– Selling {shares_to_sell} shares = +${abs(inv_real_estate):,.0f} cash")
#           else:  # Hold
#               inv_real_estate = 0
#               re_share_change = 0
#               st.session_state.re_shares_input = 0  # â† Reset when holding
#               st.success(f"âœ“ Holding {current_re_shares} shares (${current_re_shares * real_estate_price:,.0f})")
#       with col_re2:
#           monthly_rate = game_state.get('real_estate_return_rate', 84.0) / 12
#           st.metric("è‚¡åˆ©ï¼ˆæ¯æœˆï¼‰ï¼ˆà¹€à¸‡à¸´à¸™à¸›à¸±à¸™à¸œà¸¥à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰", f"{monthly_rate:.1f}%")  # Shows 7.0%
#           st.caption(f"({game_state.get('real_estate_return_rate', 84.0):.0f}% annual)")
# 
#       with col_re3:
#           if current_re_value > 0:
#               monthly_return = calculate_fund_return(current_re_value, game_state.get('real_estate_return_rate', 84.0))
#               st.metric("é æœŸè‚¡åˆ©ï¼ˆæ¯æœˆï¼‰ï¼ˆà¹€à¸‡à¸´à¸™à¸›à¸±à¸™à¸œà¸¥à¸—à¸µà¹ˆà¸„à¸²à¸”à¸§à¹ˆà¸²à¸ˆà¸°à¹„à¸”à¹‰à¸£à¸±à¸šà¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ï¼‰", f"${monthly_return:,.2f}")
# 
# 
# 
# 
# 
#     # ========== END OF INVESTMENT TABS ==========
# 
#     # Make sure ALL variables are defined (in case user didn't interact with tabs)
#     if 'inv_etf' not in locals():
#         inv_etf = 0
#         etf_share_change = 0
#     if 'inv_mutual' not in locals():
#         inv_mutual = 0
#         mutual_share_change = 0
#     if 'inv_biomedical' not in locals():
#         inv_biomedical = 0
#         bio_share_change = 0
#     if 'inv_real_estate' not in locals():
#         inv_real_estate = 0
#         re_share_change = 0
# 
#     # ========== CALCULATE FINAL SAVINGS ==========
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Start with money after expenses
#     available_money = player_data['total_asset'] - total_fixed_expenses
# 
#     # Add loan
#     available_money += inv_loan
# 
#     # Deduct lottery
#     available_money -= lottery_amount
# 
#     # Calculate total invested in BUY operations
#     total_invested = 0
#     if inv_etf > 0:
#         total_invested += inv_etf
#     if inv_mutual > 0:
#         total_invested += inv_mutual
#     if inv_biomedical > 0:
#         total_invested += inv_biomedical
#     if inv_real_estate > 0:
#         total_invested += inv_real_estate
# 
#     # If selling, add cash back
#     if inv_etf < 0:
#         available_money += abs(inv_etf)
#     if inv_mutual < 0:
#         available_money += abs(inv_mutual)
#     if inv_biomedical < 0:
#         available_money += abs(inv_biomedical)
#     if inv_real_estate < 0:
#         available_money += abs(inv_real_estate)
# 
#     # Whatever is left = savings
#     savings = available_money - total_invested
# 
#     # ========== SHOW PLANNED ALLOCATION PIE CHART ==========
#     st.markdown("<br>", unsafe_allow_html=True)
#     st.markdown("### ğŸ¥§ ç›®å‰æŠ•è³‡é…ç½®ï¼ˆà¸ªà¸±à¸”à¸ªà¹ˆà¸§à¸™à¸à¸²à¸£à¸¥à¸‡à¸—à¸¸à¸™à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ï¼‰")
# 
#     # Calculate what holdings will be after this month's trades
#     etf_price = get_stock_price('etf_set', game_state['current_month'])
#     mutual_price = get_stock_price('mutual', game_state['current_month'])
#     bio_price = get_stock_price('biomedical', game_state['current_month'])
#     re_price = get_stock_price('real_estate', game_state['current_month'])
# 
#     # New shares after trades
#     current_etf_shares = player_data.get('etf_shares', 0)
#     current_mutual_shares = player_data.get('mutual_shares', 0)
#     current_bio_shares = player_data.get('biomedical_shares', 0)
#     current_re_shares = player_data.get('real_estate_shares', 0)
# 
#     new_etf_shares = current_etf_shares + etf_share_change
#     new_mutual_shares = current_mutual_shares + mutual_share_change
#     new_bio_shares = current_bio_shares + bio_share_change
#     new_re_shares = current_re_shares + re_share_change
# 
#     # Use the CALCULATED values
#     investments = {
#         'Savings': savings,
#         'ETF': new_etf_shares * etf_price,
#         'Mutual': new_mutual_shares * mutual_price,
#         'Biomedical': new_bio_shares * bio_price,
#         'Real Estate': new_re_shares * re_price,
#         'Lottery': lottery_amount
#     }
# 
#     # Remove zero values
#     investments = {k: v for k, v in investments.items() if v > 0}
# 
#     if investments:
#         fig = go.Figure(data=[go.Pie(
#             labels=list(investments.keys()),
#             values=list(investments.values()),
#             hole=0.4,
#             marker=dict(colors=['#667eea', '#48bb78', '#f093fb', '#f5576c', '#4facfe'])
#         )])
#         fig.update_layout(height=400)
#         st.plotly_chart(fig, use_container_width=True)
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # é€™è£¡è¨ˆç®—å®Œ savings äº†
#     st.markdown(f"<h3 style='text-align: center; color: white;'>4ï¸âƒ£ å‰©é¤˜ä½œç‚ºå„²è“„ï¼ˆà¹€à¸‡à¸´à¸™à¸—à¸µà¹ˆà¹€à¸«à¸¥à¸·à¸­à¹€à¸›à¹‡à¸™à¹€à¸‡à¸´à¸™à¸­à¸­à¸¡ï¼‰: ${savings:,.0f}</h3>", unsafe_allow_html=True)
# 
#     if savings < 0:
#         st.error("âŒ You've allocated more than available! Reduce your investments.")
#         return  # âœ… é€™è£¡çš„ç¸®æ’å¿…é ˆè·Ÿ st.error å°é½Š
# 
#     # éŒ¢å¤ ç”¨çš„æƒ…æ³ä¸‹ï¼Œç¹¼çºŒå¾€ä¸‹è·‘
#     if savings < 1 and inv_loan == 0:
#         st.warning("âš ï¸ Warning: Savings below $1 will result in bankruptcy!")
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
# # ========== VIEW ACCOUNTING BUTTON (MOVED HERE, ABOVE REFRESH) ==========
#     if st.button("ğŸ“Š æŸ¥çœ‹äº¤æ˜“ç´€éŒ„ï¼ˆà¸”à¸¹à¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸à¸²à¸£à¸—à¸³à¸˜à¸¸à¸£à¸à¸£à¸£à¸¡ï¼‰", use_container_width=True, key="accounting_waiting"):
#         st.session_state.page = 'student_accounting'
#         st.rerun()
# 
#     # Submit button
#     if st.button("ğŸ“¤ æäº¤ä½ çš„æŠ•è³‡é…ç½®ï¼ˆà¸ªà¹ˆà¸‡à¸à¸²à¸£à¸ˆà¸±à¸”à¸ªà¸£à¸£à¸à¸²à¸£à¸¥à¸‡à¸—à¸¸à¸™à¸‚à¸­à¸‡à¸„à¸¸à¸“ï¼‰", use_container_width=True, type="primary"):
#         st.session_state.show_confirm = True
# 
# 
#     if st.session_state.get('show_confirm', False):
#         st.warning("âš ï¸ Once submitted, you cannot change! Are you sure?")
#         col_yes, col_no = st.columns(2)
# 
#         with col_yes:
#             if st.button("âœ… Yes, I'm Sure!", use_container_width=True):
#                 if savings < 1 and inv_loan == 0:
#                     player_data['is_broke'] = True
# 
#                 # Calculate new share counts and values for stocks
#                 biomedical_price = get_stock_price('biomedical', game_state['current_month'])
#                 real_estate_price = get_stock_price('real_estate', game_state['current_month'])
# 
#                 current_bio_shares = player_data.get('biomedical_shares', 0)
#                 current_re_shares = player_data.get('real_estate_shares', 0)
# 
#                 new_bio_shares = current_bio_shares + bio_share_change
#                 new_re_shares = current_re_shares + re_share_change
# 
#                 new_bio_value = new_bio_shares * biomedical_price
#                 new_re_value = new_re_shares * real_estate_price
# 
#                 # ========== CALCULATE CURRENT MONTH RESULTS ==========
#                 current_month = game_state['current_month']
# 
#                 # Start with liquid cash
#                 liquid_cash = player_data['total_asset']
# 
#                 # 1. DEDUCT EXPENSES
#                 total_expenses = player_data.get('exact_cost_daily', 0) + player_data.get('exact_cost_food', 0)
#                 liquid_cash -= total_expenses
#                 save_transaction(group_name, {
#                     'type': 'Expense',
#                     'amount': total_expenses,
#                     'description': f'Living expenses',
#                     'month': current_month
#                 })
# 
#                 # 2. ADD LOAN (increases liquid cash)
#                 if inv_loan > 0:
#                     liquid_cash += inv_loan
# 
#                 # 3. DEDUCT LOAN INTEREST
#                 if player_data.get('loan_balance', 0) + inv_loan > 0:
#                     new_loan_balance = player_data.get('loan_balance', 0) + inv_loan
#                     loan_interest = calculate_loan_interest(new_loan_balance, game_state['loan_rate'])
#                     liquid_cash -= loan_interest
# 
#                     save_transaction(group_name, {
#                         'type': 'Interest Paid',
#                         'amount': loan_interest,
#                         'description': f'Loan interest at {game_state["loan_rate"]:.1f}% annual',
#                         'month': current_month
#                     })
# 
#                 # 4. DEDUCT LOTTERY
#                 liquid_cash -= lottery_amount
# 
#                 # 5. BUY/SELL ETF (affects liquid cash)
#                 etf_price = get_stock_price('etf_set', current_month)
#                 current_etf_shares_val = player_data.get('etf_shares', 0)
#                 new_etf_shares = current_etf_shares_val + etf_share_change
#                 new_etf_value = new_etf_shares * etf_price
# 
#                 # Buying = money leaves, Selling = money returns
#                 if etf_share_change > 0:
#                     liquid_cash -= (etf_share_change * etf_price)
#                     save_transaction(group_name, {
#                         'type': 'Investment Purchase',
#                         'amount': etf_share_change * etf_price,
#                         'description': f'Bought {etf_share_change} ETF shares at ${etf_price}',
#                         'month': current_month
#                     })
#                 elif etf_share_change < 0:
#                     liquid_cash += abs(etf_share_change * etf_price)
#                     save_transaction(group_name, {
#                         'type': 'Investment Sale',
#                         'amount': abs(etf_share_change) * etf_price,
#                         'description': f'Sold {abs(etf_share_change)} ETF shares at ${etf_price}',
#                         'month': current_month
#                     })
# 
#                 # ETF management fee (deducted from liquid cash)
#                 if new_etf_value > 0:
#                     monthly_fee = calculate_fund_fee(new_etf_value, game_state.get('etf_fee', 0.3))
#                     liquid_cash -= monthly_fee
# 
#                     save_transaction(group_name, {
#                         'type': 'Fee',
#                         'amount': monthly_fee,
#                         'description': 'ETF management fee',
#                         'month': current_month
#                     })
# 
#                 # 6. BUY/SELL MUTUAL (same logic)
#                 mutual_price = get_stock_price('mutual', current_month)
#                 current_mutual_shares_val = player_data.get('mutual_shares', 0)
#                 new_mutual_shares = current_mutual_shares_val + mutual_share_change
#                 new_mutual_value = new_mutual_shares * mutual_price
# 
#                 if mutual_share_change > 0:
#                     liquid_cash -= (mutual_share_change * mutual_price)
#                     save_transaction(group_name, {
#                         'type': 'Investment Purchase',
#                         'amount': mutual_share_change * mutual_price,
#                         'description': f'Bought {mutual_share_change} Mutual shares at ${mutual_price}',
#                         'month': current_month
#                     })
#                 elif mutual_share_change < 0:
#                     liquid_cash += abs(mutual_share_change * mutual_price)
#                     save_transaction(group_name, {
#                         'type': 'Investment Sale',
#                         'amount': abs(mutual_share_change) * mutual_price,
#                         'description': f'Sold {abs(mutual_share_change)} Mutual shares at ${mutual_price}',
#                         'month': current_month
#                     })
# 
#                 if new_mutual_value > 0:
#                     monthly_fee = calculate_fund_fee(new_mutual_value, game_state.get('mutual_fee', 2.0))
#                     liquid_cash -= monthly_fee
# 
#                     save_transaction(group_name, {
#                         'type': 'Fee',
#                         'amount': monthly_fee,
#                         'description': 'Mutual Fund management fee',
#                         'month': current_month
#                     })
# 
#                 # 7. BUY/SELL BIOMEDICAL
#                 biomedical_price = get_stock_price('biomedical', current_month)
#                 current_bio_shares = player_data.get('biomedical_shares', 0)
#                 new_bio_shares = current_bio_shares + bio_share_change
#                 new_bio_value = new_bio_shares * biomedical_price
# 
#                 if bio_share_change > 0:
#                     liquid_cash -= (bio_share_change * biomedical_price)
#                     save_transaction(group_name, {
#                         'type': 'Stock Purchase',
#                         'amount': bio_share_change * biomedical_price,
#                         'description': f'Bought {bio_share_change} Biomedical at ${biomedical_price}',
#                         'month': current_month
#                     })
#                 elif bio_share_change < 0:
#                     liquid_cash += abs(bio_share_change * biomedical_price)
#                     save_transaction(group_name, {
#                         'type': 'Stock Sale',
#                         'amount': abs(bio_share_change) * biomedical_price,
#                         'description': f'Sold {abs(bio_share_change)} Biomedical at ${biomedical_price}',
#                         'month': current_month
#                     })
# 
#                 # Biomedical earns returns (added to liquid cash)
#                 if new_bio_value > 0:
#                     bio_return = calculate_fund_return(new_bio_value, game_state.get('biomedical_return_rate', 15.0))
#                     liquid_cash += bio_return
# 
#                     save_transaction(group_name, {
#                         'type': 'Investment Gain',
#                         'amount': bio_return,
#                         'description': f'Biomedical return ({game_state.get("biomedical_return_rate", 15.0):.1f}% annual)',
#                         'month': current_month
#                     })
# 
#                 # 8. BUY/SELL REAL ESTATE
#                 real_estate_price = get_stock_price('real_estate', current_month)
#                 current_re_shares = player_data.get('real_estate_shares', 0)
#                 new_re_shares = current_re_shares + re_share_change
#                 new_re_value = new_re_shares * real_estate_price
# 
#                 if re_share_change > 0:
#                     liquid_cash -= (re_share_change * real_estate_price)
#                     save_transaction(group_name, {
#                         'type': 'Stock Purchase',
#                         'amount': re_share_change * real_estate_price,
#                         'description': f'Bought {re_share_change} Real Estate at ${real_estate_price}',
#                         'month': current_month
#                     })
#                 elif re_share_change < 0:
#                     liquid_cash += abs(re_share_change * real_estate_price)
#                     save_transaction(group_name, {
#                         'type': 'Stock Sale',
#                         'amount': abs(re_share_change) * real_estate_price,
#                         'description': f'Sold {abs(re_share_change)} Real Estate at ${real_estate_price}',
#                         'month': current_month
#                     })
# 
#                 # Real Estate earns returns (added to liquid cash)
#                 if new_re_value > 0:
#                     re_return = calculate_fund_return(new_re_value, game_state.get('real_estate_return_rate', 7.0))
#                     liquid_cash += re_return
# 
#                     save_transaction(group_name, {
#                         'type': 'Investment Gain',
#                         'amount': re_return,
#                         'description': f'Real Estate return ({game_state.get("real_estate_return_rate", 7.0):.1f}% annual)',
#                         'month': current_month
#                     })
# 
#                 # 9. PROCESS LOTTERY
#                 if lottery_amount > 0:
#                     roll = random.random()
# 
#                     lottery_record = {
#                         'month': current_month,
#                         'stake': lottery_amount,
#                         'won': False,
#                         'prize': 0
#                     }
# 
#                     if roll < 0.01:
#                         prize = lottery_amount * 2.0
#                         liquid_cash += prize
#                         lottery_record['won'] = True
#                         lottery_record['prize'] = prize
# 
#                         save_transaction(group_name, {
#                             'type': 'Investment Gain',
#                             'amount': prize,
#                             'description': f'ğŸ° Lottery JACKPOT! (200% return)',
#                             'month': current_month
#                         })
# 
#                     elif roll < 0.11:
#                         prize = lottery_amount * 1.3
#                         liquid_cash += prize
#                         lottery_record['won'] = True
#                         lottery_record['prize'] = prize
# 
#                         save_transaction(group_name, {
#                             'type': 'Investment Gain',
#                             'amount': prize,
#                             'description': f'ğŸ° Lottery WIN! (130% return)',
#                             'month': current_month
#                         })
#                     else:
#                         # Already deducted above
#                         save_transaction(group_name, {
#                             'type': 'Investment Loss',
#                             'amount': lottery_amount,
#                             'description': f'ğŸ° Lottery LOST',
#                             'month': current_month
#                         })
# 
#                     if 'lottery_history' not in player_data:
#                         player_data['lottery_history'] = []
#                     player_data['lottery_history'].append(lottery_record)
# 
#                 # 10. SAVINGS INTEREST (on liquid cash)
#                 if liquid_cash > 0:
#                     interest = calculate_monthly_compound_interest(liquid_cash, game_state['interest_rate'])
#                     liquid_cash += interest
# 
#                     save_transaction(group_name, {
#                         'type': 'Interest Earned',
#                         'amount': interest,
#                         'description': f'Savings interest (compound)',
#                         'month': current_month
#                     })
# 
#                 # ========== END CALCULATIONS ==========
#                 # total_asset = ONLY liquid cash (what's left after buying everything)
#                 # Stocks/funds are tracked separately in their own fields
# 
#                 # Update player data
#                 # Update player data
#                 player_data.update({
#                     'total_asset': liquid_cash,  # â† This should be your final savings amount!
#                     'savings': liquid_cash,      # â† Same as total_asset
#                     'etf': new_etf_value,        # â† Track but NOT in total_asset
#                     'etf_shares': new_etf_shares,
#                     'mutual': new_mutual_value,  # â† Track but NOT in total_asset
#                     'mutual_shares': new_mutual_shares,
#                     'biomedical': new_bio_value, # â† Track but NOT in total_asset
#                     'biomedical_shares': new_bio_shares,
#                     'real_estate': new_re_value, # â† Track but NOT in total_asset
#                     'real_estate_shares': new_re_shares,
#                     'loan_balance': player_data.get('loan_balance', 0) + inv_loan,
#                     'submitted': True
#                 })
# 
#                 update_player_data(group_name, player_data)
#                 # Take snapshot AFTER updating
#                 take_monthly_snapshot(group_name, player_data, game_state)
#                 st.session_state.show_confirm = False
# 
#                 # Loan transaction
#                 if inv_loan > 0:
#                     save_transaction(group_name, {
#                         'type': 'Loan Borrowed',
#                         'amount': inv_loan,
#                         'description': f'Borrowed at {game_state["loan_rate"]:.1f}% annual interest',
#                         'month': current_month
#                     })
# 
#                 st.session_state.show_confirm = False
#                 st.session_state.inv_loan = 0
#                 st.session_state.lottery_amount = 0
#                 st.session_state.etf_action = 'Hold'
#                 st.session_state.etf_shares_input = 0
#                 st.session_state.mutual_action = 'Hold'
#                 st.session_state.mutual_shares_input = 0
#                 st.session_state.bio_action = 'Hold'
#                 st.session_state.bio_shares_input = 0
#                 st.session_state.re_action = 'Hold'
#                 st.session_state.re_shares_input = 0
#                 st.session_state.show_confirm = False
#                 st.success("ğŸ‰ Submission successful!")
#                 st.snow()
#                 time.sleep(1)
#                 st.rerun()
#         with col_no:
#             if st.button("âŒ Cancel", use_container_width=True):
#                 st.session_state.show_confirm = False
#                 st.rerun()
# def student_accounting_page():
#     """Show detailed transaction history and P&L"""
#     group_name = st.session_state.group_name
#     player_data = get_player_data(group_name)
#     game_state = get_game_state()
# 
#     if not player_data:
#         st.error("âŒ Player data not found. Please login again.")
#         return
# 
#     st.markdown("<h1 class='center-text' style='color: white;'>ğŸ“Š Accounting & Transaction History</h1>", unsafe_allow_html=True)
#     st.markdown(f"<h2 class='center-text' style='color: white;'>Team: {group_name}</h2>", unsafe_allow_html=True)
# 
#     # Back button
#     if st.button("â† Back to Game", use_container_width=False):
#         st.session_state.page = 'student_game'
#         st.rerun()
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Get all transactions
#     all_transactions = get_transactions(group_name)
# 
#     if not all_transactions:
#         st.info("ğŸ“ No transaction history yet. Start playing to see your financial records!")
#         return
# 
#     # Month filter
#     available_months = sorted(list(set(t.get('month', 1) for t in all_transactions)))
# 
#     col1, col2 = st.columns([1, 3])
#     with col1:
#         selected_month = st.selectbox(
#             "Filter by Month:",
#             options=['All Months'] + [f"Month {m}" for m in available_months],
#             key="month_filter"
#         )
# 
#     # Filter transactions
#     if selected_month == 'All Months':
#         filtered_transactions = all_transactions
#         display_month = "All Time"
#     else:
#         month_num = int(selected_month.split()[1])
#         filtered_transactions = [t for t in all_transactions if t.get('month') == month_num]
#         display_month = f"Month {month_num}"
# 
#     st.markdown(f"### ğŸ“‹ Transaction Ledger - {display_month}")
# 
#     # Calculate totals
#     income_total = sum(t['amount'] for t in filtered_transactions if t['type'] in ['Income', 'Investment Gain', 'Interest Earned', 'Investment Sale', 'Stock Sale', 'Loan Borrowed'])
#     expense_total = sum(t['amount'] for t in filtered_transactions if t['type'] in ['Expense', 'Fee', 'Interest Paid', 'Investment Loss', 'Investment Purchase', 'Stock Purchase', 'Loan Repayment'])
#     net = income_total - expense_total
# 
#     # Summary metrics
#     col1, col2, col3, col4 = st.columns(4)
#     with col1:
#         st.metric("ğŸ’° Total Income", f"${income_total:,.2f}")
#     with col2:
#         st.metric("ğŸ’¸ Total Expenses", f"${expense_total:,.2f}")
#     #with col3:
#         #st.metric("ğŸ“Š Net P&L", f"${net:,.2f}", delta=f"{net:+,.2f}")
#     with col4:
#         st.metric("ğŸ“ Transactions", len(filtered_transactions))
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Transaction table
#     if filtered_transactions:
#         # Create DataFrame
#         transaction_data = []
#         for t in filtered_transactions:
#             transaction_data.append({
#                 'Date': t.get('timestamp', datetime.now()).strftime('%Y-%m-%d %H:%M'),
#                 'Month': f"Month {t.get('month', 'N/A')}",
#                 'Type': t['type'],
#                 'Description': t['description'],
#                 'Amount': f"${t['amount']:,.2f}",
#                 'Category': 'ğŸ’° Income' if t['type'] in ['Income', 'Investment Gain', 'Interest Earned', 'Investment Sale', 'Stock Sale'] else 'ğŸ’¸ Expense'
#             })
# 
#         df = pd.DataFrame(transaction_data)
# 
#         # Display with color coding
#         st.dataframe(
#             df,
#             use_container_width=True,
#             hide_index=True,
#             height=400
#         )
# 
#         # Download button
#         csv = df.to_csv(index=False)
#         st.download_button(
#             "ğŸ“¥ Download Transaction History (CSV)",
#             data=csv,
#             file_name=f"{group_name}_transactions_{datetime.now().strftime('%Y%m%d')}.csv",
#             mime="text/csv",
#             use_container_width=True
#         )
#     else:
#         st.info("No transactions found for the selected period.")
# 
#     # Monthly breakdown
#     if selected_month == 'All Months' and len(available_months) > 1:
#         st.markdown("<br>", unsafe_allow_html=True)
#         st.markdown("### ğŸ“ˆ Monthly P&L Summary")
# 
#         monthly_summary = []
#         for month in available_months:
#             month_trans = [t for t in all_transactions if t.get('month') == month]
#             month_income = sum(t['amount'] for t in month_trans if t['type'] in ['Income', 'Investment Gain', 'Interest Earned', 'Investment Sale', 'Stock Sale'])
#             month_expense = sum(t['amount'] for t in month_trans if t['type'] in ['Expense', 'Fee', 'Interest Paid', 'Investment Loss', 'Investment Purchase', 'Stock Purchase'])
#             month_net = month_income - month_expense
# 
#             monthly_summary.append({
#                 'Month': f"Month {month}",
#                 'Income': f"${month_income:,.2f}",
#                 'Expenses': f"${month_expense:,.2f}",
#                 'Net P&L': f"${month_net:,.2f}"
#             })
# 
#         df_summary = pd.DataFrame(monthly_summary)
#         st.dataframe(df_summary, use_container_width=True, hide_index=True)
# # ============= ADMIN DASHBOARD =============
# 
# def admin_dashboard_page():
#     game_state = get_game_state()
#     all_players = get_all_players()
# 
#     st.markdown("<div class='emoji-decor'>ğŸ‘¨â€ğŸ’¼ğŸ“ŠğŸ’¼</div>", unsafe_allow_html=True)
#     st.markdown("<h1 class='center-text' style='color: white; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);'>éŠæˆ²ä¸»æŒäººå„€è¡¨æ¿</h1>", unsafe_allow_html=True)
# 
#     # Control buttons
#     col_btn1, col_btn2, col_btn3, col_btn4, col_btn5 = st.columns(5)
# 
#     with col_btn1:
#         if st.button("ğŸ”„ Refresh Data", use_container_width=True):
#             st.cache_data.clear()
#             st.rerun()
# 
#     with col_btn2:
#         if st.button("ğŸ² éš¨æ©Ÿäº‹ä»¶", use_container_width=True):
#             st.session_state.page = 'admin_events'
#             st.rerun()
# 
#     with col_btn3:
#       if st.button("â¡ï¸ å‰å¾€ä¸‹å€‹æœˆ æ”¶å…¥+10K", use_container_width=True):
#           with st.spinner("Processing month advancement..."):
#               event, event_log = advance_month()
#               st.cache_data.clear()
# 
#           # Show event results
#           st.success(f"âœ… Advanced to {MONTHS[(game_state['current_month'])]}")
#           st.info(f"ğŸ“¢ Event: {event['name']}")
# 
#           if event_log['effects_applied']:
#               st.write("**Effects Applied:**")
#               for effect in event_log['effects_applied']:
#                   st.write(f"- {effect}")
# 
#           time.sleep(2)
#           st.rerun()
# 
#     with col_btn4:
#         if st.button("ğŸ“Š Statistics", use_container_width=True):
#             st.session_state.page = 'statistics'
#             st.rerun()
# 
#     with col_btn5:
#         if st.button("ğŸ† çµç®—éŠæˆ²", use_container_width=True):
#             st.session_state.page = 'end_game'
#             st.rerun()
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
# 
# 
#     # Show current month event (existing code continues here)
#     current_month = game_state['current_month']
#     event = get_month_event(current_month)
#     # Show current month event
#     current_month = game_state['current_month']
#     event = get_month_event(current_month)
# 
#     st.markdown(f"<div class='event-alert'>{event['alert']}</div>", unsafe_allow_html=True)
# 
#     st.markdown(f"<h2 style='font-size: 2.1rem; color: #1a1a1a;'>ğŸ“… {event['name']}</h2>", unsafe_allow_html=True)
#     st.markdown(f"<p style='font-size: 1.7rem; color: #4a5568; line-height: 1.6;'>{event['description']}</p>", unsafe_allow_html=True)
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     st.markdown("<br>", unsafe_allow_html=True)
#     # ========== ADD LOAN REPAYMENT HERE ==========
#     st.markdown("### ğŸ’³ ä½¿ç©å®¶å„Ÿé‚„è²¸æ¬¾")
# 
#     # Check if any players have loans
#     players_with_loans = {name: data for name, data in all_players.items() if data.get('loan_balance', 0) > 0}
# 
#     if players_with_loans:
#         st.info(f"ğŸ“Š {len(players_with_loans)} players currently have outstanding loans")
# 
#         if st.button("ğŸ’° Force All Players to Repay Loans", use_container_width=True, type="primary"):
#             st.session_state.show_loan_repay_confirm = True
# 
#         if st.session_state.get('show_loan_repay_confirm', False):
#             st.warning("âš ï¸ This will IMMEDIATELY deduct loan principals from all players' assets!")
# 
#             col_yes, col_no = st.columns(2)
# 
#             with col_yes:
#                 if st.button("âœ… Yes, Force Repayment", use_container_width=True):
#                     repayment_log = []
# 
#                     for group_name, data in players_with_loans.items():
#                         loan_amount = data.get('loan_balance', 0)
# 
#                         # Deduct loan from total assets
#                         data['total_asset'] -= loan_amount
#                         data['loan_balance'] = 0
# 
#                         # Save transaction
#                         save_transaction(group_name, {
#                             'type': 'Loan Repayment',
#                             'amount': loan_amount,
#                             'description': f'Forced loan principal repayment',
#                             'month': game_state['current_month']
#                         })
# 
#                         update_player_data(group_name, data)
#                         repayment_log.append(f"{group_name}: ${loan_amount:,.0f}")
# 
#                     st.session_state.show_loan_repay_confirm = False
#                     st.success(f"âœ… Loan repayment completed for {len(repayment_log)} players!")
# 
#                     with st.expander("ğŸ“‹ Repayment Details"):
#                         for log in repayment_log:
#                             st.write(f"- {log}")
# 
#                     st.cache_data.clear()
#                     time.sleep(2)
#                     st.rerun()
# 
#             with col_no:
#                 if st.button("âŒ Cancel", use_container_width=True):
#                     st.session_state.show_loan_repay_confirm = False
#                     st.rerun()
#     else:
#         st.success("âœ… No players currently have outstanding loans")
# 
#     st.markdown("<br>", unsafe_allow_html=True)
#     # ========== END LOAN REPAYMENT ==========
# 
#     # Add this in admin_dashboard_page(), after the loan repayment section (around line 5200)
# 
#     _ ="""
#     #st.markdown("### âš¡ Force Update Game Rates")
#     #st.info("Use this to update Firebase with corrected fee and return rates")
# 
#     if st.button("âš¡ FORCE UPDATE All Game Rates", use_container_width=True, type="primary"):
#         update_game_state({
#             'loan_rate': 72.0,              # 6% monthly
#             'etf_fee': 0.24,                # 0.02% monthly = 0.24% annual
#             'mutual_fee': 24.0,             # 2% monthly = 24% annual
#             'biomedical_return_rate': 180.0, # 15% monthly = 180% annual
#             'real_estate_return_rate': 84.0, # 7% monthly = 84% annual
#             'etf_return_rate': 10.0,
#             'mutual_return_rate': 10.5,
#             'interest_rate': 2.0,
#             'inflation_rate': 2.0
#         })
#         st.success("âœ… All rates updated successfully!")
#         st.balloons()
#         st.cache_data.clear()
#         time.sleep(1)
#         st.rerun()
#     """
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Month control and delete players section
#     col_control1, col_control2 = st.columns(2)
# 
#     with col_control1:
#         st.markdown("### â®ï¸ Go Back to Month")
#         target_month = st.number_input(
#             "Jump to month:",
#             min_value=1,
#             max_value=game_state['current_month'],
#             value=game_state['current_month'],
#             step=1,
#             key="target_month"
#         )
#         if st.button("â®ï¸ Jump to Month", use_container_width=True):
#             if target_month < game_state['current_month']:
#                 update_game_state({'current_month': target_month})
#                 st.success(f"âœ… Jumped back to Month {target_month}!")
#                 st.cache_data.clear()
#                 time.sleep(0.5)
#                 st.rerun()
#             else:
#                 st.warning("Can only go back to previous months!")
# 
#     with col_control2:
#         st.markdown("### ğŸ—‘ï¸ Delete Player")
#         if all_players:
#             player_to_delete = st.selectbox(
#                 "Select player to remove:",
#                 options=["-- Select Player --"] + list(all_players.keys()),
#                 key="delete_player_select"
#             )
#             if player_to_delete != "-- Select Player --":
#                 if st.button(f"ğŸ—‘ï¸ Delete {player_to_delete}", use_container_width=True, type="primary"):
#                     try:
#                         db.collection('players').document(player_to_delete).delete()
#                         st.success(f"âœ… Deleted {player_to_delete}!")
#                         st.cache_data.clear()
#                         time.sleep(0.5)
#                         st.rerun()
#                     except Exception as e:
#                         st.error(f"Error deleting player: {e}")
#         else:
#             st.info("No players to delete")
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Reset Game button
#     st.markdown("### ğŸ”„ Reset Game")
#     if st.button("ğŸ”„ Reset Game to January", use_container_width=True, type="primary"):
#         st.session_state.show_reset_confirm = True
# 
#     if st.session_state.get('show_reset_confirm', False):
#         st.warning("âš ï¸ WARNING: This will DELETE ALL PLAYERS and reset to Month 1!")
#         col_confirm, col_cancel = st.columns(2)
#         with col_confirm:
#             if st.button("âœ… Yes, Reset Everything", use_container_width=True):
#                 # Delete all players AND snapshots
#                 delete_all_players()
#                 delete_all_snapshots()
#                 delete_all_transactions()
#                 # Reset game state
#                 update_game_state({
#                     'current_month': 1,
#                     'exact_cost_daily': 4000,
#                     'exact_cost_food': 4000
#                 })
#                 st.session_state.show_reset_confirm = False
#                 st.success("âœ… Game reset to January! All players deleted.")
#                 st.cache_data.clear()
#                 time.sleep(1)
#                 st.rerun()
#         with col_cancel:
#             if st.button("âŒ Cancel", use_container_width=True):
#                 st.session_state.show_reset_confirm = False
#                 st.rerun()
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Download button - convert datetime objects to strings
#     def convert_to_json_serializable(obj):
#         """Convert Firebase datetime objects to strings"""
#         if isinstance(obj, dict):
#             return {k: convert_to_json_serializable(v) for k, v in obj.items()}
#         elif isinstance(obj, list):
#             return [convert_to_json_serializable(item) for item in obj]
#         elif hasattr(obj, 'isoformat'):  # datetime objects
#             return obj.isoformat()
#         else:
#             return obj
# 
#     download_state = {
#         'players_data': convert_to_json_serializable(all_players),
#         'current_month': game_state['current_month'],
#         'exact_cost_daily': game_state['exact_cost_daily'],
#         'exact_cost_food': game_state['exact_cost_food']
#     }
#     st.download_button(
#         "ğŸ’¾ Download Game State",
#         data=json.dumps(download_state, ensure_ascii=False, indent=2),
#         file_name=f"game_state_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
#         mime="application/json",
#         use_container_width=True
#     )
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # Preview next month's event
#     next_month = current_month + 1
#     if next_month <= 12:
#         next_event = get_month_event(next_month)
#         with st.expander(f"ğŸ‘€ Preview: Next Month's Event"):
#             st.write(f"**{next_event['name']}**")
#             st.write(next_event['description'])
# 
#     # Stats
#     col_stat1, col_stat2 = st.columns(2)
#     with col_stat1:
#         st.markdown(f"<div class='month-badge' style='font-size: 1.5rem;'>ğŸ“… Current Month: {get_current_month_name()}</div>", unsafe_allow_html=True)
#     with col_stat2:
#         st.markdown(f"<div class='month-badge' style='font-size: 1.5rem; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);'>ğŸ‘¥ Total Players: {len(all_players)}</div>", unsafe_allow_html=True)
# 
#     if not all_players:
#         st.info("ğŸ“¢ ç›®å‰å°šç„¡ç©å®¶åŠ å…¥ï¼Œè«‹å°‡éŠæˆ²é€£çµåˆ†äº«çµ¦å­¸ç”Ÿï¼ ï¼ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µà¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¹€à¸‚à¹‰à¸²à¸£à¹ˆà¸§à¸¡ à¹‚à¸›à¸£à¸”à¹à¸Šà¸£à¹Œà¸¥à¸´à¸‡à¸à¹Œà¹€à¸à¸¡à¹ƒà¸«à¹‰à¸à¸±à¸šà¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™!ï¼‰")
#         return
# 
#     st.markdown("<br><br>", unsafe_allow_html=True)
#     st.markdown("<h2 style='text-align: center;'>ğŸ“Š Player Overview ğŸ“Š</h2>", unsafe_allow_html=True)
# 
#     # Display players in grid
#     players_list = list(all_players.items())
#     cols_per_row = 3
# 
#     for i in range(0, len(players_list), cols_per_row):
#         cols = st.columns(cols_per_row)
#         for j in range(cols_per_row):
#             idx = i + j
#             if idx < len(players_list):
#                 group_name, data = players_list[idx]
#                 with cols[j]:
#                     display_player_card(group_name, data)
# 
# def display_player_card(group_name, data):
#     """Display player card with pie chart"""
# 
#     status = "âœ… Submitted" if data.get('submitted', False) else "â³ Pending"
#     # â† ADD BROKE EMOJI HERE
#     broke_emoji = " ğŸ’€" if data.get('is_broke', False) else ""
#     st.markdown(f"### ğŸ‘¤ {group_name}{broke_emoji}")
# 
#     st.markdown(f"**{status}**")
#     st.markdown(f"<h4 style='color: #48bb78;'>ğŸ’° Savings: ${data['total_asset']:,.0f}</h4>", unsafe_allow_html=True)
# 
#     if data.get('loan_balance', 0) > 0:
#         st.warning(f"ğŸ’³ è²¸æ¬¾ï¼ˆà¹€à¸‡à¸´à¸™à¸à¸¹à¹‰ï¼‰: ${data['loan_balance']:,.0f}")
# 
#     # Pie chart - NOW WITH ETF AND MUTUAL
#     labels = []
#     values = []
#     colors = []
# 
#     if data.get('savings', 0) > 0:
#         labels.append('ğŸ¦ Savings')
#         values.append(data['savings'])
#         colors.append('#667eea')
# 
#     # â† ADD ETF
#     if data.get('etf', 0) > 0:
#         labels.append('ğŸ“ˆ ETF')
#         values.append(data['etf'])
#         colors.append('#48bb78')
# 
#     # â† ADD MUTUAL FUND
#     if data.get('mutual', 0) > 0:
#         labels.append('ğŸ“Š Mutual')
#         values.append(data['mutual'])
#         colors.append('#f093fb')
# 
#     if data.get('biomedical', 0) > 0:
#         labels.append('ğŸ§¬ Biomedical')
#         values.append(data['biomedical'])
#         colors.append('#f5576c')
# 
#     if data.get('real_estate', 0) > 0:
#         labels.append('ğŸ  Pruksa Real Estateï¼ˆà¸à¸¤à¸à¸©à¸² à¹€à¸£à¸µà¸¢à¸¥à¹€à¸­à¸ªà¹€à¸•à¸—ï¼‰')
#         values.append(data['real_estate'])
#         colors.append('#4facfe')
# 
#     if values:
#         fig = go.Figure(data=[go.Pie(
#             labels=labels,
#             values=values,
#             marker=dict(colors=colors),
#             hole=0.4,
#             textinfo='label+percent',
#             textfont=dict(size=10)
#         )])
# 
#         fig.update_layout(
#             height=250,
#             margin=dict(l=10, r=10, t=10, b=10),
#             showlegend=False
#         )
# 
#         st.plotly_chart(fig, use_container_width=True, key=f"pie_{group_name}")
# 
#     with st.expander("ğŸ“Š View Details"):
#         st.write(f"**Savings:** ${data.get('savings', 0):,}")
#         st.write(f"**ETF:** ${data.get('etf', 0):,} ({data.get('etf_shares', 0)} shares)")  # â† ADDED
#         st.write(f"**å…±åŒåŸºé‡‘:** ${data.get('mutual', 0):,} ({data.get('mutual_shares', 0)} shares)")  # â† ADDED
#         st.write(f"**ç”Ÿé†«æ–°å‰µ:** ${data.get('biomedical', 0):,} ({data.get('biomedical_shares', 0)} shares)")
#         st.write(f"**Pruksa Real Estate:** ${data.get('real_estate', 0):,} ({data.get('real_estate_shares', 0)} shares)")
#         if data.get('loan_balance', 0) > 0:
#             st.write(f"**Loan Balance:** ${data['loan_balance']:,}")
#         st.write(f"**ç ´ç”¢:** {'ğŸ’€ Yes' if data.get('is_broke', False) else 'âœ… No'}")
# 
# 
# def advance_month():
#     """Advance to next month"""
#     game_state = get_game_state()
#     all_players = get_all_players()
#     current_month = game_state['current_month']
#     new_month = current_month + 1
# 
#     # Apply monthly event
#     event, event_log = apply_monthly_event(new_month, game_state, all_players)
# 
#     # Refresh players
#     all_players = get_all_players()
# 
#     # Process each player
#     for group_name, data in all_players.items():
#         if not data.get('is_broke', False):
# 
#             # Start with current savings (liquid cash only)
#             liquid_cash = data.get('total_asset', 0)
# 
#             # ========== 1. ADD MONTHLY INCOME ($10,000) ==========
#             if game_state.get('skip_next_income', False):
#                 save_transaction(group_name, {
#                     'type': 'Income',
#                     'amount': 0,
#                     'description': 'ğŸ’” No salary',
#                     'month': new_month
#                 })
#             else:
#                 monthly_income = 10000
#                 liquid_cash += monthly_income
# 
#                 save_transaction(group_name, {
#                     'type': 'Income',
#                     'amount': monthly_income,
#                     'description': 'Monthly salary',
#                     'month': new_month
#                 })
# 
#             # ========== 2. EXPENSES ALREADY DEDUCTED IN SUBMISSION! ==========
#             # NOTE: Expenses are deducted when player submits, NOT here!
#             # The next month's expenses will be deducted when they submit for next month
# 
#             # ========== 3. UPDATE STOCK PRICES (unrealized) ==========
#             if data.get('etf_shares', 0) > 0:
#                 old_price = get_stock_price('etf_set', current_month)
#                 new_price = get_stock_price('etf_set', new_month)
#                 shares = data['etf_shares']
#                 old_value = data.get('etf', 0)
#                 new_value = shares * new_price
#                 data['etf'] = new_value
# 
#             if data.get('mutual_shares', 0) > 0:
#                 old_price = get_stock_price('mutual', current_month)
#                 new_price = get_stock_price('mutual', new_month)
#                 shares = data['mutual_shares']
#                 old_value = data.get('mutual', 0)
#                 new_value = shares * new_price
#                 data['mutual'] = new_value
# 
#             if data.get('biomedical_shares', 0) > 0:
#                 old_price = get_stock_price('biomedical', current_month)
#                 new_price = get_stock_price('biomedical', new_month)
#                 shares = data['biomedical_shares']
#                 old_value = data.get('biomedical', 0)
#                 new_value = shares * new_price
#                 data['biomedical'] = new_value
# 
#             if data.get('real_estate_shares', 0) > 0:
#                 old_price = get_stock_price('real_estate', current_month)
#                 new_price = get_stock_price('real_estate', new_month)
#                 shares = data['real_estate_shares']
#                 old_value = data.get('real_estate', 0)
#                 new_value = shares * new_price
#                 data['real_estate'] = new_value
# 
#             # ========== 4. DIVIDENDS (Bio & RE only) ==========
#             if data.get('biomedical', 0) > 0:
#                 bio_dividend = calculate_fund_return(data['biomedical'], game_state.get('biomedical_return_rate', 15.0))
#                 liquid_cash += bio_dividend
# 
#                 save_transaction(group_name, {
#                     'type': 'Investment Gain',
#                     'amount': bio_dividend,
#                     'description': f'Biomedical dividend ({game_state.get("biomedical_return_rate", 15.0):.1f}% annual)',
#                     'month': new_month
#                 })
# 
#             if data.get('real_estate', 0) > 0:
#                 re_dividend = calculate_fund_return(data['real_estate'], game_state.get('real_estate_return_rate', 7.0))
#                 liquid_cash += re_dividend
# 
#                 save_transaction(group_name, {
#                     'type': 'Investment Gain',
#                     'amount': re_dividend,
#                     'description': f'Real Estate dividend ({game_state.get("real_estate_return_rate", 7.0):.1f}% annual)',
#                     'month': new_month
#                 })
# 
#             # ========== 5. DEDUCT FEES ==========
#             if data.get('etf', 0) > 0:
#                 etf_fee = calculate_fund_fee(data['etf'], game_state.get('etf_fee', 0.3))
#                 liquid_cash -= etf_fee
# 
#                 save_transaction(group_name, {
#                     'type': 'Fee',
#                     'amount': etf_fee,
#                     'description': 'ETF management fee',
#                     'month': new_month
#                 })
# 
#             if data.get('mutual', 0) > 0:
#                 mutual_fee = calculate_fund_fee(data['mutual'], game_state.get('mutual_fee', 2.0))
#                 liquid_cash -= mutual_fee
# 
#                 save_transaction(group_name, {
#                     'type': 'Fee',
#                     'amount': mutual_fee,
#                     'description': 'Mutual Fund management fee',
#                     'month': new_month
#                 })
# 
#             # ========== 6. LOAN INTEREST ==========
#             if data.get('loan_balance', 0) > 0:
#                 loan_interest = calculate_loan_interest(data['loan_balance'], game_state['loan_rate'])
#                 liquid_cash -= loan_interest
# 
#                 save_transaction(group_name, {
#                     'type': 'Interest Paid',
#                     'amount': loan_interest,
#                     'description': f'Loan interest ({game_state["loan_rate"]:.1f}% annual)',
#                     'month': new_month
#                 })
# 
#             # ========== 7. SAVINGS INTEREST ==========
#             if liquid_cash > 0:
#                 savings_interest = calculate_monthly_compound_interest(liquid_cash, game_state['interest_rate'])
#                 liquid_cash += savings_interest
# 
#                 save_transaction(group_name, {
#                     'type': 'Interest Earned',
#                     'amount': savings_interest,
#                     'description': 'Savings interest (compound)',
#                     'month': new_month
#                 })
# 
#             # ========== 8. UPDATE PLAYER DATA ==========
#             data['savings'] = liquid_cash
#             data['total_asset'] = liquid_cash
#             data['month'] = new_month
#             data['exact_cost_daily'] = game_state['exact_cost_daily']
#             data['exact_cost_food'] = game_state['exact_cost_food']
#             data['submitted'] = False
# 
#             if data['total_asset'] < 1:
#                 data['is_broke'] = True
# 
#             update_player_data(group_name, data)
# 
#     # Clear skip flag
#     if game_state.get('skip_next_income', False):
#         update_game_state({'skip_next_income': False})
# 
#     # Update game state
#     update_game_state({'current_month': new_month})
# 
#     return event, event_log
# 
# # ============= ADMIN EVENTS PAGE =============
# 
# def admin_events_page():
#     game_state = get_game_state()
#     all_players = get_all_players()
# 
#     # Load images from Google Drive
#     from google.colab import drive
#     import os
# 
#     if not os.path.exists('/content/drive'):
#         drive.mount('/content/drive')
# 
#     tariff_image_path = '/content/drive/MyDrive/ç†è²¡éŠæˆ²python/files/tariff.png'
#     tariff_image_exists = os.path.exists(tariff_image_path)
#     jason_image_path = '/content/drive/MyDrive/ç†è²¡éŠæˆ²python/files/jason dad.png'
#     jason_image_exists = os.path.exists(jason_image_path)
#     early_election_image_path = '/content/drive/MyDrive/ç†è²¡éŠæˆ²python/files/early election.png'
#     early_election_image_exists = os.path.exists(early_election_image_path)
#     car_image_path = '/content/drive/MyDrive/ç†è²¡éŠæˆ²python/files/car.jpg'
#     car_image_exists = os.path.exists(car_image_path)
# 
#     st.markdown("<h1 class='center-text' style='color: white; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);'>éš¨æ©Ÿäº‹ä»¶</h1>", unsafe_allow_html=True)
# 
#     if st.button("â† Back to Dashboard", use_container_width=False):
#         st.session_state.page = 'admin_dashboard'
#         st.rerun()
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     event_choice = st.selectbox(
#         "ğŸ´ Select Event Card",
#         ["-- Select an Event --", "Card I: Trade War", "Card V: Car Accident"]
#     )
# 
#     if event_choice == "Card I: Trade War":
#         st.markdown("### ğŸŒ Card I: Trade War")
# 
#         # Display image
#         if tariff_image_exists:
#             st.image(tariff_image_path, caption="Global Trade War", use_container_width=True)
#         else:
#             st.warning(f"âš ï¸ Image not found at: {tariff_image_path}")
# 
#         st.markdown("<p style='font-size: 2.5rem;'><strong>èªªæ˜ï¼š</strong>ç¾åœ‹ç¸½çµ±å·æ™®ç™¼å‹•é—œç¨…è²¿æ˜“æˆ° ï¼ˆà¸›à¸£à¸°à¸˜à¸²à¸™à¸²à¸˜à¸´à¸šà¸”à¸µà¸ªà¸«à¸£à¸±à¸à¸¯ à¹‚à¸”à¸™à¸±à¸¥à¸”à¹Œ à¸—à¸£à¸±à¸¡à¸›à¹Œ à¹€à¸›à¸´à¸”à¸‰à¸²à¸à¸ªà¸‡à¸„à¸£à¸²à¸¡à¸à¸²à¸£à¸„à¹‰à¸²à¸”à¹‰à¸§à¸¢à¸¡à¸²à¸•à¸£à¸à¸²à¸£à¸ à¸²à¸©à¸µà¸¨à¸¸à¸¥à¸à¸²à¸à¸£ï¼‰</p>", unsafe_allow_html=True)
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             if st.button("ğŸ² æ­ç¤ºçµæœï¼ˆà¹€à¸›à¸´à¸”à¹€à¸œà¸¢à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œï¼‰", key="reveal_tariff", use_container_width=True):
#                 st.session_state.tariff_revealed = True
#                 st.rerun()
# 
#         if st.session_state.get('tariff_revealed', False):
#             st.markdown("<div style='background: #fffaf0; color: #744210; padding: 1rem; border-radius: 8px; border-left: 4px solid #dd6b20; font-size: 2.5rem; font-weight: 600;'>âš ï¸ çµæœï¼š é£²é£Ÿæˆæœ¬å¢åŠ  10% ï¼ˆà¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œ: à¸„à¹ˆà¸²à¸­à¸²à¸«à¸²à¸£à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™ 10%ï¼‰</div>", unsafe_allow_html=True)
# 
#             with col2:
#                 if st.button("âœ… Apply Effect", type="primary", key="apply_tariff", use_container_width=True):
#                     new_food_cost = int(game_state['exact_cost_food'] * 1.1)
#                     update_game_state({'exact_cost_food': new_food_cost})
# 
#                     for group_name, data in all_players.items():
#                         data['exact_cost_food'] = new_food_cost
#                         update_player_data(group_name, data)
# 
#                     st.success(f"ğŸ¯ Food cost increased to ${new_food_cost}!")
#                     st.balloons()
#                     st.session_state.tariff_revealed = False
#                     st.cache_data.clear()
#                     time.sleep(1)
#                     st.rerun()
# 
#     elif event_choice == "Card II: NVIDIA Revolution":
#         st.markdown("### ğŸš€ Card II: NVIDIA Revolution")
#         # Display image
#         if jason_image_exists:
#             st.image(jason_image_path, caption="jason_dad", use_container_width=True)
#         else:
#             st.warning(f"âš ï¸ Image not found at: {tariff_image_path}")
#         st.markdown("**Description:** Revolutionary super-computing technology developed by NVIDIA")
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             if st.button("ğŸ² æ­ç¤ºçµæœï¼ˆà¹€à¸›à¸´à¸”à¹€à¸œà¸¢à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œï¼‰", key="reveal_nvidia", use_container_width=True):
#                 st.session_state.nvidia_revealed = True
#                 st.rerun()
# 
#         if st.session_state.get('nvidia_revealed', False):
#             st.success("**Result:** All stocks increase 20%!")
# 
#             with col2:
#                 if st.button("âœ… Apply Effect", type="primary", key="apply_nvidia", use_container_width=True):
#                     for group_name, data in all_players.items():
#                         if data.get('stock', 0) > 0:
#                             profit = data['stock'] * 0.2
#                             data['stock'] = data['stock'] + profit
#                             data['total_asset'] = data['total_asset'] + profit
#                             update_player_data(group_name, data)
# 
#                     st.success("ğŸ“ˆ All stock investments increased by 20%!")
#                     st.balloons()
#                     st.session_state.nvidia_revealed = False
#                     st.cache_data.clear()
#                     time.sleep(1)
#                     st.rerun()
# 
#     elif event_choice == "Card III: Hurricane hits":
#         st.markdown("###Card III: Hurricane hits")
#         st.markdown("**Description:** Hurricane hits the major area of agricultural")
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             if st.button("ğŸ² æ­ç¤ºçµæœï¼ˆà¹€à¸›à¸´à¸”à¹€à¸œà¸¢à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œï¼‰", key="reveal_hurricane", use_container_width=True):
#                 st.session_state.nvidia_revealed = True
#                 st.rerun()
# 
#         if st.session_state.get('hurricane_revealed', False):
#             st.success("**Result:** Daily Cost increase 20%")
# 
#             with col2:
#                 if st.button("âœ… Apply Effect", type="primary", key="apply_tariff", use_container_width=True):
#                     new_food_cost = int(game_state['exact_cost_food'] * 1.1)
#                     update_game_state({'exact_cost_food': new_food_cost})
# 
#                     for group_name, data in all_players.items():
#                         data['exact_cost_food'] = new_food_cost
#                         update_player_data(group_name, data)
# 
#                     st.success(f"ğŸ¯ Food cost increased to ${new_food_cost}!")
#                     st.balloons()
#                     st.session_state.tariff_revealed = False
#                     st.cache_data.clear()
#                     time.sleep(1)
#                     st.rerun()
# 
# 
#     elif event_choice == "Card IV: House dissolved":
#         st.markdown("### ğŸ—³ï¸ Card IV: House dissolved")
# 
#         # Display image
#         if early_election_image_exists:
#             st.image(early_election_image_path, caption="Thailand Early Election", use_container_width=False, width=600)
#         else:
#             st.warning(f"âš ï¸ Image not found at: {early_election_image_path}")
# 
#         st.markdown("**Description:** Prime Minister Anutin Charnvirakul moved late Thursday to dissolve parliament, setting the stage for an early election")
# 
# 
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             if st.button("ğŸ² æ­ç¤ºçµæœï¼ˆà¹€à¸›à¸´à¸”à¹€à¸œà¸¢à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œï¼‰", key="reveal_election", use_container_width=True):
#                 st.session_state.election_revealed = True
#                 st.rerun()
# 
#         if st.session_state.get('election_revealed', False):
#             st.warning("**Result:** Baht climbed while ETF tracking Thai stocks fell. ETF drops 5%!")
# 
#             with col2:
#                 if st.button("âœ… Apply Effect", type="primary", key="apply_election", use_container_width=True):
#                     # Apply 5% drop to all ETF holdings
#                     for group_name, data in all_players.items():
#                         if data.get('fund_type') == 'etf' and data.get('fund', 0) > 0:
#                             loss = data['fund'] * 0.05
#                             data['fund'] = data['fund'] - loss
#                             data['total_asset'] = data['total_asset'] - loss
#                             update_player_data(group_name, data)
# 
#                             # Save transaction
#                             save_transaction(group_name, {
#                                 'type': 'Investment Loss',
#                                 'amount': loss,
#                                 'description': 'ETF dropped 5% due to Thailand early election',
#                                 'month': game_state['current_month']
#                             })
# 
#                     st.success(f"ğŸ¯ All ETF holdings dropped by 5%!")
#                     st.balloons()
#                     st.session_state.election_revealed = False
#                     st.cache_data.clear()
#                     time.sleep(1)
#                     st.rerun()
#     elif event_choice == "Card V: Car Accident":
#       st.markdown("### ğŸ¦´ Card V: Car Accident")
# 
#       # Display image
#       if car_image_exists:
#             st.image(car_image_path, caption="Car accident", use_container_width=False, width=600)
#       else:
#           st.warning(f"âš ï¸ Image not found at: {early_election_image_path}")
#       st.markdown( "<p style='font-size: 2.5rem;'><b>èªªæ˜ï¼š</b>ä½ é­é‡è»Šç¦ï¼Œä¸‹å€‹æœˆå°‡ç„¡æ³•å·¥ä½œã€‚ï¼ˆà¸„à¸¸à¸“à¸›à¸£à¸°à¸ªà¸šà¸­à¸¸à¸šà¸±à¸•à¸´à¹€à¸«à¸•à¸¸à¸—à¸²à¸‡à¸£à¸–à¸¢à¸™à¸•à¹Œ à¸—à¸³à¹ƒà¸«à¹‰à¸„à¸¸à¸“à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰à¹ƒà¸™à¹€à¸”à¸·à¸­à¸™à¸«à¸™à¹‰à¸²ï¼‰</p>", unsafe_allow_html=True )
#       st.markdown("<br>", unsafe_allow_html=True)
# 
#       col1, col2 = st.columns(2)
# 
#       with col1:
#           if st.button("ğŸ² æ­ç¤ºçµæœï¼ˆà¹€à¸›à¸´à¸”à¹€à¸œà¸¢à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œï¼‰", key="reveal_leg", use_container_width=True):
#               st.session_state.leg_revealed = True
#               st.rerun()
# 
#       if st.session_state.get('leg_revealed', False):
#           st.markdown("<div style='background: #fff5f5; color: #742a2a; padding: 1rem; border-radius: 8px; border-left: 4px solid #e53e3e; font-size: 2.5rem; font-weight: 600;'>âŒ çµæœï¼ˆà¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œï¼‰ï¼šæœ¬æœˆç„¡æ”¶å…¥ï¼ï¼ˆæ¯æœˆè–ªè³‡ = $0ï¼‰ï¼ˆà¹„à¸¡à¹ˆà¸¡à¸µà¸£à¸²à¸¢à¹„à¸”à¹‰à¹ƒà¸™à¹€à¸”à¸·à¸­à¸™à¸™à¸µà¹‰! à¹€à¸‡à¸´à¸™à¹€à¸”à¸·à¸­à¸™à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™ = $0ï¼‰</div>", unsafe_allow_html=True)
#           with col2:
#               if st.button("âœ… å¥—ç”¨æ•ˆæœï¼ˆà¹ƒà¸Šà¹‰à¸œà¸¥à¸à¸£à¸°à¸—à¸šï¼‰", type="primary", key="apply_leg", use_container_width=True):
#                   # Mark that next advance_month should skip income
#                   update_game_state({'skip_next_income': True})
# 
#                   st.success(f"ğŸ¯ Next month will have NO income!")
#                   st.balloons()
#                   st.session_state.leg_revealed = False
#                   st.cache_data.clear()
#                   time.sleep(1)
#                   st.rerun()
# # ============= STATISTICS PAGE =============
# 
# def statistics_page():
#     import numpy as np
#     from scipy import stats as scipy_stats
# 
#     st.markdown("<h1 class='center-text' style='color: white; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);'>Statistical Analysis Dashboard</h1>", unsafe_allow_html=True)
# 
#     if st.button("â† Back to Dashboard", use_container_width=False):
#         st.session_state.page = 'admin_dashboard'
#         st.rerun()
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     all_players = get_all_players()
#     game_state = get_game_state()
# 
#     if not all_players:
#         st.warning("No player data available yet!")
#         return
# 
#     # Prepare data
#     player_names = list(all_players.keys())
#     total_assets = [data['total_asset'] for data in all_players.values()]
#     savings_list = [data.get('savings', 0) for data in all_players.values()]
#     etf_list = [data.get('etf', 0) for data in all_players.values()]
#     stock_list = [data.get('stock', 0) for data in all_players.values()]
#     startup_list = [data.get('startup', 0) for data in all_players.values()]
# 
#     # Analysis selection
#     analysis_type = st.selectbox(
#         "ğŸ“Š Select Analysis Type",
#         [
#             "Overview Statistics",
#             "Historical Trends",
#             "Asset Distribution",
#             "Investment Allocation Patterns",
#             "Risk vs Return Analysis",
#             "Correlation Analysis",
#             "Player Comparison",
#             "Portfolio Diversity Score",
#             "Monte Carlo Simulation"
#         ]
#     )
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     # ========== OVERVIEW STATISTICS ==========
#     if analysis_type == "Overview Statistics":
#         st.markdown("### ğŸ“ˆ Descriptive Statistics")
# 
#         col1, col2, col3, col4 = st.columns(4)
# 
#         with col1:
#             st.metric("Total Players", len(all_players))
#             st.metric("Average Assets", f"${np.mean(total_assets):,.0f}")
# 
#         with col2:
#             st.metric("Median Assets", f"${np.median(total_assets):,.0f}")
#             st.metric("Std Deviation", f"${np.std(total_assets):,.0f}")
# 
#         with col3:
#             st.metric("Max Assets", f"${np.max(total_assets):,.0f}")
#             st.metric("Min Assets", f"${np.min(total_assets):,.0f}")
# 
#         with col4:
#             st.metric("Total Wealth", f"${np.sum(total_assets):,.0f}")
#             st.metric("Wealth Range", f"${np.max(total_assets) - np.min(total_assets):,.0f}")
# 
#         st.markdown("<br>", unsafe_allow_html=True)
# 
#         # Summary table
#         st.markdown("### ğŸ“‹ Detailed Summary")
#         summary_data = {
#             'Player': player_names,
#             'Total Assets': [f"${x:,.0f}" for x in total_assets],
#             'Savings': [f"${x:,.0f}" for x in savings_list],
#             'ETF': [f"${x:,.0f}" for x in etf_list],
#             'Stock': [f"${x:,.0f}" for x in stock_list],
#             'Startup': [f"${x:,.0f}" for x in startup_list]
#         }
#         st.table(summary_data)
# 
#     # ========== HISTORICAL TRENDS ==========
#     elif analysis_type == "Historical Trends":
#         st.markdown("### ğŸ“ˆ Historical Trends Over Time")
# 
#         # Check if any player has history
#         has_history = any('history' in data and len(data['history'].get('months', [])) > 0
#                          for data in all_players.values())
# 
#         if not has_history:
#             st.warning("â³ No historical data yet! Historical data is recorded when you advance to the next month.")
#             st.info("ğŸ’¡ Tip: After advancing to Month 2 or later, you'll see trend lines showing how each player's assets change over time.")
#             return
# 
#         # Select what to visualize
#         metric_choice = st.radio(
#             "Select metric to track:",
#             ["Total Assets", "Individual Investments", "All Players Comparison"]
#         )
# 
#         if metric_choice == "Total Assets":
#             st.markdown("#### ğŸ’° Total Assets Over Time")
# 
#             fig = go.Figure()
# 
#             for player_name, data in all_players.items():
#                 if 'history' in data and len(data['history'].get('months', [])) > 0:
#                     history = data['history']
#                     # Add current month's data
#                     months = history['months'] + [game_state['current_month']]
#                     assets = history['total_assets'] + [data['total_asset']]
# 
#                     fig.add_trace(go.Scatter(
#                         x=months,
#                         y=assets,
#                         mode='lines+markers',
#                         name=player_name,
#                         line=dict(width=3),
#                         marker=dict(size=8)
#                     ))
# 
#             fig.update_layout(
#                 title="Asset Growth Over Time",
#                 xaxis_title="Month",
#                 yaxis_title="Total Assets ($)",
#                 height=500,
#                 hovermode='x unified'
#             )
#             st.plotly_chart(fig, use_container_width=True)
# 
#             # Growth rate analysis
#             st.markdown("#### ğŸ“Š Growth Rate Analysis")
#             col1, col2 = st.columns(2)
# 
#             growth_rates = {}
#             for player_name, data in all_players.items():
#                 if 'history' in data and len(data['history'].get('total_assets', [])) > 0:
#                     initial = data['history']['total_assets'][0]
#                     current = data['total_asset']
#                     months = len(data['history']['months'])
#                     if initial > 0 and months > 0:
#                         growth_rate = ((current - initial) / initial) * 100 / months
#                         growth_rates[player_name] = growth_rate
# 
#             if growth_rates:
#                 sorted_growth = sorted(growth_rates.items(), key=lambda x: x[1], reverse=True)
# 
#                 with col1:
#                     st.markdown("**ğŸš€ Fastest Growing:**")
#                     for i, (player, rate) in enumerate(sorted_growth[:3], 1):
#                         st.write(f"{i}. {player}: +{rate:.1f}% per month")
# 
#                 with col2:
#                     st.markdown("**ğŸŒ Slowest Growing:**")
#                     for i, (player, rate) in enumerate(sorted_growth[-3:], 1):
#                         st.write(f"{i}. {player}: {rate:+.1f}% per month")
# 
#         elif metric_choice == "Individual Investments":
#             st.markdown("#### ğŸ¯ Investment Breakdown Over Time")
# 
#             selected_player = st.selectbox("Select player:", player_names)
# 
#             if selected_player:
#                 data = all_players[selected_player]
# 
#                 if 'history' not in data or len(data['history'].get('months', [])) == 0:
#                     st.warning(f"{selected_player} has no historical data yet.")
#                 else:
#                     history = data['history']
#                     months = history['months'] + [game_state['current_month']]
# 
#                     fig = go.Figure()
# 
#                     # Add traces for each investment type
#                     investments = {
#                         'Savings': (history['savings'] + [data.get('savings', 0)], '#667eea'),
#                         'ETF': (history['etf'] + [data.get('etf', 0)], '#48bb78'),
#                         'Stock': (history['stock'] + [data.get('stock', 0)], '#f093fb'),
#                         'Startup': (history['startup'] + [data.get('startup', 0)], '#f5576c')
#                     }
# 
#                     for name, (values, color) in investments.items():
#                         fig.add_trace(go.Scatter(
#                             x=months,
#                             y=values,
#                             mode='lines+markers',
#                             name=name,
#                             line=dict(width=2, color=color),
#                             marker=dict(size=6),
#                             stackgroup='one'
#                         ))
# 
#                     fig.update_layout(
#                         title=f"{selected_player}'s Investment Allocation Over Time",
#                         xaxis_title="Month",
#                         yaxis_title="Amount ($)",
#                         height=500,
#                         hovermode='x unified'
#                     )
#                     st.plotly_chart(fig, use_container_width=True)
# 
#                     # Strategy consistency
#                     st.markdown("#### ğŸ¯ Strategy Consistency")
#                     if len(history['months']) >= 2:
#                         # Calculate variance in allocation percentages
#                         total_assets_history = history['total_assets']
#                         savings_pct = [history['savings'][i] / total_assets_history[i] * 100
#                                       if total_assets_history[i] > 0 else 0
#                                       for i in range(len(history['savings']))]
# 
#                         variance = np.var(savings_pct) if len(savings_pct) > 1 else 0
# 
#                         if variance < 10:
#                             st.success("âœ… Very consistent strategy (low variance)")
#                         elif variance < 50:
#                             st.info("â„¹ï¸ Moderately consistent strategy")
#                         else:
#                             st.warning("âš ï¸ Highly variable strategy (experimenting)")
# 
#         elif metric_choice == "All Players Comparison":
#             st.markdown("#### ğŸ‘¥ All Players Asset Comparison")
# 
#             fig = go.Figure()
# 
#             colors = ['#667eea', '#48bb78', '#f093fb', '#f5576c', '#4facfe', '#feca57', '#ee5a6f', '#c44569']
# 
#             for idx, (player_name, data) in enumerate(all_players.items()):
#                 if 'history' in data and len(data['history'].get('months', [])) > 0:
#                     history = data['history']
#                     months = history['months'] + [game_state['current_month']]
#                     assets = history['total_assets'] + [data['total_asset']]
# 
#                     fig.add_trace(go.Scatter(
#                         x=months,
#                         y=assets,
#                         mode='lines+markers',
#                         name=player_name,
#                         line=dict(width=2, color=colors[idx % len(colors)]),
#                         marker=dict(size=6)
#                     ))
# 
#             fig.update_layout(
#                 title="All Players - Asset Growth Comparison",
#                 xaxis_title="Month",
#                 yaxis_title="Total Assets ($)",
#                 height=600,
#                 hovermode='x unified',
#                 legend=dict(
#                     orientation="v",
#                     yanchor="top",
#                     y=1,
#                     xanchor="left",
#                     x=1.05
#                 )
#             )
#             st.plotly_chart(fig, use_container_width=True)
# 
#             # Leader board over time
#             st.markdown("#### ğŸ† Leader Changes Over Time")
#             st.info("See who was leading at each month of the game!")
# 
#     # ========== ASSET DISTRIBUTION ==========
#     elif analysis_type == "Asset Distribution":
#         st.markdown("### ğŸ“Š Asset Distribution Analysis")
# 
#         chart_type = st.radio("Select Chart Type:", ["Histogram", "Box Plot", "Violin Plot"])
# 
#         if chart_type == "Histogram":
#             fig = go.Figure()
#             fig.add_trace(go.Histogram(
#                 x=total_assets,
#                 nbinsx=10,
#                 marker_color='#667eea',
#                 name='Asset Distribution'
#             ))
#             fig.update_layout(
#                 title="Distribution of Total Assets",
#                 xaxis_title="Total Assets ($)",
#                 yaxis_title="Number of Players",
#                 height=500
#             )
#             st.plotly_chart(fig, use_container_width=True)
# 
#         elif chart_type == "Box Plot":
#             fig = go.Figure()
#             fig.add_trace(go.Box(
#                 y=total_assets,
#                 name='Total Assets',
#                 marker_color='#667eea',
#                 boxmean='sd'
#             ))
#             fig.update_layout(
#                 title="Asset Distribution (Box Plot)",
#                 yaxis_title="Total Assets ($)",
#                 height=500
#             )
#             st.plotly_chart(fig, use_container_width=True)
# 
#         elif chart_type == "Violin Plot":
#             fig = go.Figure()
#             fig.add_trace(go.Violin(
#                 y=total_assets,
#                 name='Assets',
#                 box_visible=True,
#                 marker_color='#667eea'
#             ))
#             fig.update_layout(
#                 title="Asset Distribution (Violin Plot)",
#                 yaxis_title="Total Assets ($)",
#                 height=500
#             )
#             st.plotly_chart(fig, use_container_width=True)
# 
#     # ========== INVESTMENT ALLOCATION ==========
#     elif analysis_type == "Investment Allocation Patterns":
#         st.markdown("### ğŸ¯ Investment Allocation Analysis")
# 
#         # Average allocation
#         avg_savings = np.mean(savings_list)
#         avg_etf = np.mean(etf_list)
#         avg_stock = np.mean(stock_list)
#         avg_startup = np.mean(startup_list)
# 
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.markdown("#### Average Allocation (Amount)")
#             fig = go.Figure(data=[go.Pie(
#                 labels=['Savings', 'ETF', 'Stock', 'Startup'],
#                 values=[avg_savings, avg_etf, avg_stock, avg_startup],
#                 hole=0.4,
#                 marker=dict(colors=['#667eea', '#48bb78', '#f093fb', '#f5576c'])
#             )])
#             fig.update_layout(height=400)
#             st.plotly_chart(fig, use_container_width=True)
# 
#         with col2:
#             st.markdown("#### Allocation Comparison")
#             fig = go.Figure()
#             fig.add_trace(go.Bar(name='Savings', x=player_names, y=savings_list, marker_color='#667eea'))
#             fig.add_trace(go.Bar(name='ETF', x=player_names, y=etf_list, marker_color='#48bb78'))
#             fig.add_trace(go.Bar(name='Stock', x=player_names, y=stock_list, marker_color='#f093fb'))
#             fig.add_trace(go.Bar(name='Startup', x=player_names, y=startup_list, marker_color='#f5576c'))
#             fig.update_layout(barmode='stack', height=400, xaxis_title="Player", yaxis_title="Amount ($)")
#             st.plotly_chart(fig, use_container_width=True)
# 
#     # ========== RISK VS RETURN ==========
#     elif analysis_type == "Risk vs Return Analysis":
#         st.markdown("### âš–ï¸ Risk vs Return Analysis")
# 
#         # Calculate risk score (higher investment in risky assets = higher risk)
#         risk_scores = []
#         for data in all_players.values():
#             total = data['total_asset']
#             if total > 0:
#                 risk = (data.get('stock', 0) * 0.5 + data.get('startup', 0) * 1.0) / total * 100
#             else:
#                 risk = 0
#             risk_scores.append(risk)
# 
#         # Scatter plot
#         fig = go.Figure()
#         fig.add_trace(go.Scatter(
#             x=risk_scores,
#             y=total_assets,
#             mode='markers+text',
#             text=player_names,
#             textposition='top center',
#             marker=dict(
#                 size=15,
#                 color=total_assets,
#                 colorscale='Viridis',
#                 showscale=True,
#                 colorbar=dict(title="Assets ($)")
#             )
#         ))
#         fig.update_layout(
#             title="Risk vs Total Assets",
#             xaxis_title="Risk Score (%)",
#             yaxis_title="Total Assets ($)",
#             height=500
#         )
#         st.plotly_chart(fig, use_container_width=True)
# 
#         # Risk categories
#         st.markdown("### ğŸ“Š Risk Profile Distribution")
#         conservative = sum(1 for r in risk_scores if r < 20)
#         moderate = sum(1 for r in risk_scores if 20 <= r < 50)
#         aggressive = sum(1 for r in risk_scores if r >= 50)
# 
#         col1, col2, col3 = st.columns(3)
#         with col1:
#             st.metric("Conservative (<20%)", conservative)
#         with col2:
#             st.metric("Moderate (20-50%)", moderate)
#         with col3:
#             st.metric("Aggressive (â‰¥50%)", aggressive)
# 
#     # ========== CORRELATION ANALYSIS ==========
#     elif analysis_type == "Correlation Analysis":
#         st.markdown("### ğŸ”— Correlation Between Investment Choices")
# 
#         # Create correlation matrix
#         data_matrix = np.array([savings_list, etf_list, stock_list, startup_list, total_assets])
#         correlation_matrix = np.corrcoef(data_matrix)
# 
#         labels = ['Savings', 'ETF', 'Stock', 'Startup', 'Total Assets']
# 
#         fig = go.Figure(data=go.Heatmap(
#             z=correlation_matrix,
#             x=labels,
#             y=labels,
#             colorscale='RdBu',
#             zmid=0,
#             text=np.round(correlation_matrix, 2),
#             texttemplate='%{text}',
#             textfont={"size": 12},
#             colorbar=dict(title="Correlation")
#         ))
#         fig.update_layout(
#             title="Correlation Matrix",
#             height=500
#         )
#         st.plotly_chart(fig, use_container_width=True)
# 
#         st.markdown("### ğŸ“Š Key Insights")
# 
#         # Find strongest correlations
#         st.write("**Strongest Positive Correlations:**")
#         for i in range(len(labels)):
#             for j in range(i+1, len(labels)):
#                 corr = correlation_matrix[i][j]
#                 if corr > 0.5:
#                     st.write(f"- {labels[i]} â†” {labels[j]}: {corr:.2f}")
# 
#         st.write("**Strongest Negative Correlations:**")
#         for i in range(len(labels)):
#             for j in range(i+1, len(labels)):
#                 corr = correlation_matrix[i][j]
#                 if corr < -0.5:
#                     st.write(f"- {labels[i]} â†” {labels[j]}: {corr:.2f}")
# 
#     # ========== PLAYER COMPARISON ==========
#     elif analysis_type == "Player Comparison":
#         st.markdown("### ğŸ‘¥ Player Comparison")
# 
#         selected_players = st.multiselect(
#             "Select players to compare:",
#             options=player_names,
#             default=player_names[:min(3, len(player_names))]
#         )
# 
#         if selected_players:
#             comparison_data = {
#                 'Metric': ['Total Assets', 'Savings', 'ETF', 'Stock', 'Startup']
#             }
# 
#             for player in selected_players:
#                 data = all_players[player]
#                 comparison_data[player] = [
#                     f"${data['total_asset']:,.0f}",
#                     f"${data.get('savings', 0):,.0f}",
#                     f"${data.get('etf', 0):,.0f}",
#                     f"${data.get('stock', 0):,.0f}",
#                     f"${data.get('startup', 0):,.0f}"
#                 ]
# 
#             st.table(comparison_data)
# 
#             # Radar chart
#             st.markdown("#### Portfolio Comparison (Radar Chart)")
#             fig = go.Figure()
# 
#             categories = ['Savings', 'ETF', 'Stock', 'Startup']
# 
#             for player in selected_players:
#                 data = all_players[player]
#                 values = [
#                     data.get('savings', 0),
#                     data.get('etf', 0),
#                     data.get('stock', 0),
#                     data.get('startup', 0)
#                 ]
#                 fig.add_trace(go.Scatterpolar(
#                     r=values,
#                     theta=categories,
#                     fill='toself',
#                     name=player
#                 ))
# 
#             fig.update_layout(
#                 polar=dict(radialaxis=dict(visible=True)),
#                 showlegend=True,
#                 height=500
#             )
#             st.plotly_chart(fig, use_container_width=True)
# 
#     # ========== PORTFOLIO DIVERSITY ==========
#     elif analysis_type == "Portfolio Diversity Score":
#         st.markdown("### ğŸŒˆ Portfolio Diversity Analysis")
# 
#         st.info("Diversity Score: Measures how well-balanced the portfolio is across different assets. Higher score = more diversified.")
# 
#         # Calculate diversity scores (Shannon entropy)
#         diversity_scores = []
#         for data in all_players.values():
#             allocations = [
#                 data.get('savings', 0),
#                 data.get('etf', 0),
#                 data.get('stock', 0),
#                 data.get('startup', 0)
#             ]
#             total = sum(allocations)
#             if total > 0:
#                 proportions = [a/total for a in allocations if a > 0]
#                 entropy = -sum(p * np.log(p) for p in proportions)
#                 # Normalize to 0-100 scale
#                 max_entropy = np.log(4)  # Maximum possible entropy with 4 categories
#                 diversity_score = (entropy / max_entropy) * 100
#             else:
#                 diversity_score = 0
#             diversity_scores.append(diversity_score)
# 
#         # Create bar chart
#         fig = go.Figure()
#         fig.add_trace(go.Bar(
#             x=player_names,
#             y=diversity_scores,
#             marker_color=diversity_scores,
#             marker=dict(
#                 colorscale='Viridis',
#                 showscale=True,
#                 colorbar=dict(title="Score")
#             ),
#             text=[f"{s:.1f}" for s in diversity_scores],
#             textposition='outside'
#         ))
#         fig.update_layout(
#             title="Portfolio Diversity Scores",
#             xaxis_title="Player",
#             yaxis_title="Diversity Score (0-100)",
#             height=500
#         )
#         st.plotly_chart(fig, use_container_width=True)
# 
#         # Rankings
#         st.markdown("### ğŸ† Diversity Rankings")
#         diversity_ranking = sorted(zip(player_names, diversity_scores), key=lambda x: x[1], reverse=True)
# 
#         for i, (player, score) in enumerate(diversity_ranking, 1):
#             if i == 1:
#                 st.success(f"ğŸ¥‡ {i}. {player} - {score:.1f} (Most Diversified)")
#             elif i == 2:
#                 st.info(f"ğŸ¥ˆ {i}. {player} - {score:.1f}")
#             elif i == 3:
#                 st.warning(f"ğŸ¥‰ {i}. {player} - {score:.1f}")
#             else:
#                 st.write(f"  {i}. {player} - {score:.1f}")
# 
#     # ========== MONTE CARLO SIMULATION ==========
#     elif analysis_type == "Monte Carlo Simulation":
#         st.markdown("### ğŸ² Monte Carlo Simulation")
# 
#         st.info("""
#         **What is Monte Carlo Simulation?**
# 
#         Monte Carlo simulation runs your game strategy thousands of times with random variations to predict likely outcomes.
# 
#         **How it works:**
#         1. Takes your current investment allocation
#         2. Simulates random market events (good and bad)
#         3. Runs 1,000+ scenarios
#         4. Shows you the range of possible outcomes
# 
#         **Why it's useful:**
#         - See probability of reaching your goals
#         - Understand risk in your strategy
#         - Compare "safe" vs "risky" approaches
#         - Learn about uncertainty in investing
#         """)
# 
#         st.markdown("---")
# 
#         # Select player to simulate
#         selected_player = st.selectbox("Select player to simulate:", player_names, key="mc_player")
# 
#         if selected_player:
#             player_data = all_players[selected_player]
# 
#             col1, col2 = st.columns(2)
# 
#             with col1:
#                 num_simulations = st.slider("Number of simulations:", 100, 10000, 1000, 100)
#                 months_ahead = st.slider("Months to simulate:", 1, 12, 6)
# 
#             with col2:
#                 st.markdown("**Current Portfolio:**")
#                 st.write(f"ğŸ’° Total: ${player_data['total_asset']:,.0f}")
#                 st.write(f"ğŸ¦ å„²è“„ à¸à¸²à¸£à¸­à¸­à¸¡à¹€à¸‡à¸´à¸™: ${player_data.get('savings', 0):,.0f}")
#                 st.write(f"ğŸ“ˆ ETF: ${player_data.get('etf', 0):,.0f}")
#                 st.write(f"ğŸ“Š Stock: ${player_data.get('stock', 0):,.0f}")
#                 st.write(f"ğŸš€ Startup: ${player_data.get('startup', 0):,.0f}")
# 
#             if st.button("ğŸ² Run Simulation", type="primary", use_container_width=True):
# 
#                 with st.spinner(f"Running {num_simulations} simulations..."):
# 
#                     # Run simulations
#                     results = []
# 
#                     for _ in range(num_simulations):
#                         # Start with current assets
#                         total = player_data['total_asset']
#                         savings = player_data.get('savings', 0)
#                         etf = player_data.get('etf', 0)
#                         stock = player_data.get('stock', 0)
#                         startup = player_data.get('startup', 0)
# 
#                         # Simulate each month
#                         for month in range(months_ahead):
#                             # Add monthly income
#                             total += 10000
# 
#                             # Simulate returns (random but realistic)
#                             # Savings: 0-0.5% per month (very safe)
#                             savings *= (1 + np.random.uniform(0, 0.005))
# 
#                             # ETF: -2% to +4% per month (moderate)
#                             etf *= (1 + np.random.uniform(-0.02, 0.04))
# 
#                             # Stock: -10% to +15% per month (volatile)
#                             stock *= (1 + np.random.uniform(-0.10, 0.15))
# 
#                             # Startup: -20% to +30% per month (very volatile)
#                             # 5% chance of total loss
#                             if np.random.random() < 0.05:
#                                 startup = 0
#                             else:
#                                 startup *= (1 + np.random.uniform(-0.20, 0.30))
# 
#                             # Recalculate total
#                             total = savings + etf + stock + startup
# 
#                             # Subtract expenses (simplified)
#                             total -= game_state['exact_cost_daily']
#                             total -= game_state['exact_cost_food']
# 
#                         results.append(total)
# 
#                     results = np.array(results)
# 
#                     # Display results
#                     st.success(f"âœ… Completed {num_simulations} simulations!")
# 
#                     st.markdown("---")
#                     st.markdown("### ğŸ“Š Simulation Results")
# 
#                     # Key statistics
#                     col1, col2, col3, col4 = st.columns(4)
# 
#                     with col1:
#                         st.metric("Average Outcome", f"${np.mean(results):,.0f}")
#                         st.metric("Current Assets", f"${player_data['total_asset']:,.0f}")
# 
#                     with col2:
#                         st.metric("Best Case (95th %)", f"${np.percentile(results, 95):,.0f}")
#                         st.metric("Median Outcome", f"${np.median(results):,.0f}")
# 
#                     with col3:
#                         st.metric("Worst Case (5th %)", f"${np.percentile(results, 5):,.0f}")
#                         st.metric("Std Deviation", f"${np.std(results):,.0f}")
# 
#                     with col4:
#                         prob_profit = np.sum(results > player_data['total_asset']) / num_simulations * 100
#                         prob_loss = 100 - prob_profit
#                         st.metric("Chance of Gain", f"{prob_profit:.1f}%")
#                         st.metric("Chance of Loss", f"{prob_loss:.1f}%")
# 
#                     # Histogram
#                     st.markdown("#### ğŸ“ˆ Distribution of Outcomes")
# 
#                     fig = go.Figure()
# 
#                     fig.add_trace(go.Histogram(
#                         x=results,
#                         nbinsx=50,
#                         marker_color='#667eea',
#                         name='Outcomes'
#                     ))
# 
#                     # Add vertical lines for key values
#                     fig.add_vline(x=player_data['total_asset'],
#                                  line_dash="dash",
#                                  line_color="red",
#                                  annotation_text="Current")
#                     fig.add_vline(x=np.mean(results),
#                                  line_dash="dash",
#                                  line_color="green",
#                                  annotation_text="Average")
# 
#                     fig.update_layout(
#                         title=f"Distribution of Assets After {months_ahead} Months",
#                         xaxis_title="Final Assets ($)",
#                         yaxis_title="Frequency",
#                         height=500
#                     )
# 
#                     st.plotly_chart(fig, use_container_width=True)
# 
#                     # Percentile analysis
#                     st.markdown("#### ğŸ“Š Percentile Analysis")
#                     st.write("**What are the chances of different outcomes?**")
# 
#                     percentiles = [10, 25, 50, 75, 90]
#                     percentile_values = [np.percentile(results, p) for p in percentiles]
# 
#                     percentile_data = {
#                         'Percentile': [f"{p}th" for p in percentiles],
#                         'Meaning': [
#                             "Worst 10% of outcomes",
#                             "Lower quarter outcomes",
#                             "Middle outcome (50/50)",
#                             "Upper quarter outcomes",
#                             "Best 10% of outcomes"
#                         ],
#                         'Asset Value': [f"${v:,.0f}" for v in percentile_values]
#                     }
# 
#                     st.table(percentile_data)
# 
#                     # Risk assessment
#                     st.markdown("#### âš ï¸ Risk Assessment")
# 
#                     risk_of_loss = np.sum(results < player_data['total_asset'] * 0.8) / num_simulations * 100
#                     chance_of_double = np.sum(results > player_data['total_asset'] * 2) / num_simulations * 100
# 
#                     col1, col2 = st.columns(2)
# 
#                     with col1:
#                         if risk_of_loss < 10:
#                             st.success(f"âœ… Low risk: Only {risk_of_loss:.1f}% chance of losing 20%+ of assets")
#                         elif risk_of_loss < 30:
#                             st.warning(f"âš ï¸ Moderate risk: {risk_of_loss:.1f}% chance of losing 20%+ of assets")
#                         else:
#                             st.error(f"âŒ High risk: {risk_of_loss:.1f}% chance of losing 20%+ of assets")
# 
#                     with col2:
#                         if chance_of_double > 30:
#                             st.success(f"ğŸš€ High growth potential: {chance_of_double:.1f}% chance of doubling assets")
#                         elif chance_of_double > 10:
#                             st.info(f"ğŸ“ˆ Moderate growth: {chance_of_double:.1f}% chance of doubling assets")
#                         else:
#                             st.warning(f"ğŸŒ Conservative: Only {chance_of_double:.1f}% chance of doubling assets")
# 
#                     # Strategy recommendation
#                     st.markdown("#### ğŸ’¡ Strategy Insights")
# 
#                     # Calculate risk score
#                     total_invested = player_data['total_asset']
#                     if total_invested > 0:
#                         risky_pct = (player_data.get('stock', 0) + player_data.get('startup', 0)) / total_invested
# 
#                         if risky_pct < 0.2:
#                             st.info("ğŸ›¡ï¸ **Conservative Strategy**: Your portfolio is very safe but growth may be limited.")
#                         elif risky_pct < 0.5:
#                             st.success("âœ… **Balanced Strategy**: Good mix of safety and growth potential!")
#                         else:
#                             st.warning("ğŸ² **Aggressive Strategy**: High risk, high reward! Consider diversifying.")
# 
# # ============= END GAME PAGE =============
# 
# def end_game_page():
#     all_players = get_all_players()
# 
#     st.markdown("<div class='emoji-decor'>ğŸ†ğŸ‰ğŸ‘‘</div>", unsafe_allow_html=True)
#     st.markdown("<h1 class='center-text'>Final Rankings - Game Over!</h1>", unsafe_allow_html=True)
# 
#     rankings = sorted(
#         [(name, data['total_asset']) for name, data in all_players.items() if not data.get('is_broke', False)],
#         key=lambda x: x[1],
#         reverse=True
#     )
# 
#     if len(rankings) >= 3:
#         st.markdown("<br><br>", unsafe_allow_html=True)
#         col1, col2, col3 = st.columns(3)
# 
#         with col1:
#             st.markdown("<h2 class='center-text'>ğŸ¥ˆ 2nd Place</h2>", unsafe_allow_html=True)
#             st.markdown(f"<div class='leaderboard-silver'><h3>{rankings[1][0]}</h3><h4>${rankings[1][1]:,.0f}</h4></div>", unsafe_allow_html=True)
# 
#         with col2:
#             st.markdown("<h1 class='center-text'>ğŸ¥‡ WINNER!</h1>", unsafe_allow_html=True)
#             st.markdown(f"<div class='leaderboard-gold'><h2>{rankings[0][0]}</h2><h3>${rankings[0][1]:,.0f}</h3></div>", unsafe_allow_html=True)
# 
#         with col3:
#             st.markdown("<h2 class='center-text'>ğŸ¥‰ 3rd Place</h2>", unsafe_allow_html=True)
#             st.markdown(f"<div class='leaderboard-bronze'><h3>{rankings[2][0]}</h3><h4>${rankings[2][1]:,.0f}</h4></div>", unsafe_allow_html=True)
# 
#     st.markdown("<br><br>", unsafe_allow_html=True)
#     st.markdown("### ğŸ“Š Complete Rankings")
# 
#     for i, (name, asset) in enumerate(rankings, 1):
#         if i == 1:
#             st.success(f"ğŸ¥‡ {i}. {name} - \${asset:,.0f}")
#         elif i == 2:
#             st.info(f"ğŸ¥ˆ {i}. {name} - \${asset:,.0f}")
#         elif i == 3:
#             st.warning(f"ğŸ¥‰ {i}. {name} - \${asset:,.0f}")
#         else:
#             st.write(f"  {i}. {name} - \${asset:,.0f}")
# 
#     st.markdown("<br>", unsafe_allow_html=True)
# 
#     if st.button("â† Back to Dashboard"):
#         st.session_state.page = 'admin_dashboard'
#         st.rerun()
# 
# # ============= MAIN ROUTER =============
# 
# def main():
#     page = st.session_state.page
# 
#     if page == 'home':
#         home_page()
#     elif page == 'admin_login':
#         admin_login_page()
#     elif page == 'student_login':
#         student_login_page()
#     elif page == 'student_game':
#         student_game_page()
#     elif page == 'student_accounting':  # â† ADD THIS
#         student_accounting_page()
#     elif page == 'admin_dashboard':
#         admin_dashboard_page()
#     elif page == 'admin_events':
#         admin_events_page()
#     elif page == 'statistics':
#         statistics_page()
#     elif page == 'end_game':
#         end_game_page()
# 
# if __name__ == "__main__":
#     main()
#